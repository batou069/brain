---
tags:
  - numpy
  - python
  - array_manipulation
  - concept
  - indexing
  - filtering
aliases:
  - Boolean Indexing NumPy
  - Boolean Array Indexing
related:
  - "[[NumPy_ndarray]]"
  - "[[NumPy_Indexing_Slicing]]"
  - "[[NumPy_Conditional_Selection]]" # Placeholder
  - "[[Boolean_Logic]]" # Placeholder
worksheet: [WS_NumPy]
date_created: <% tp.file.creation_date("YYYY-MM-DD") %>
---
# NumPy Boolean Indexing

## Definition

**Boolean Indexing** (or Boolean Array Indexing) in NumPy is a powerful technique for selecting elements from an `ndarray` based on a **boolean array** of the same shape as the original array (or a shape that can [[NumPy_Broadcasting|broadcast]] to it). Elements corresponding to `True` values in the boolean array are selected, while those corresponding to `False` values are excluded.

## Key Aspects

- **Boolean Mask:** The core idea is to create a "mask" (a boolean array) where `True` indicates elements to keep/select.
- **Condition-Based Selection:** The boolean array is typically generated by applying a comparison operator (e.g., `>`, `<`, ` ==`, ` != `) or a logical condition to the original array or another array of the same shape.
- **Resulting Array:**
    - If indexing a 1D array, the result is a 1D array containing only the selected elements.
    - If indexing a multi-dimensional array with a boolean array of the same shape, the result is usually a **1D array** containing all elements where the mask was `True`, flattened out.
    - To preserve dimensionality when selecting rows or columns, you often use boolean indexing on one axis and a full slice (`:`) on others.
- **Assignment:** Boolean indexing can also be used on the left-hand side of an assignment to modify only the elements where the condition is `True`.
- **Combining Conditions:** Logical operators (`&` for AND, `|` for OR, `~` for NOT) can be used to combine multiple boolean arrays. Parentheses `()` are crucial for correct operator precedence.

## AnyBlock Tabs: Boolean Indexing Examples

[list2tab]
- Basic Selection (1D)
	```python
	import numpy as np
	arr = np.array()
	print(f"Original array: {arr}")

	# Create a boolean mask
	mask_gt_3 = arr > 3
	print(f"Mask (arr > 3): {mask_gt_3}") # [False False False  True  True  True]

	# Select elements using the mask
	selected_elements = arr[mask_gt_3]
	print(f"Elements > 3: {selected_elements}") # [4 5 6]

	# Alternative: Direct condition
	print(f"Elements <= 2: {arr[arr <= 2]}") # [1 2]
	```
- Selection (2D)
	```python
	import numpy as np
	matrix = np.array([, , ])
	print(f"Original matrix:\n{matrix}")

	# Mask for elements greater than 4
	mask_gt_4 = matrix > 4
	print(f"Mask (matrix > 4):\n{mask_gt_4}")
	# [[False False False]
	#  [False  True  True]
	#  [ True  True  True]]

	# Select elements using the mask (results in a 1D array)
	selected_matrix_elements = matrix[mask_gt_4]
	print(f"Elements > 4 (flattened): {selected_matrix_elements}")
	# [5 6 7 8 9]

	# Select entire rows where the first element of the row is > 1
	row_mask = matrix[:, 0] > 1 # Boolean array for rows
	print(f"Row mask (first element > 1): {row_mask}") # [False True True]
	selected_rows = matrix[row_mask, :] # or matrix[row_mask]
	print(f"Rows where first element > 1:\n{selected_rows}")
	# [[4 5 6]
	#  [7 8 9]]
	```
- Combined Conditions
	```python
	import numpy as np
	arr = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]

	# Elements greater than 2 AND less than 7
	mask_combined = (arr > 2) & (arr < 7)
	print(f"Mask (arr > 2) & (arr < 7): {mask_combined}")
	# [F F F T T T T F F F] (abbreviated)
	print(f"Elements > 2 AND < 7: {arr[mask_combined]}") # [3 4 5 6]

	# Elements equal to 1 OR greater than or equal to 8
	mask_or = (arr == 1) | (arr >= 8)
	print(f"Elements == 1 OR >= 8: {arr[mask_or]}") # [1 8 9]
	```
- Assignment with Boolean Indexing
	```python
	import numpy as np
	arr = np.arange(5) # [0 1 2 3 4]
	print(f"Original array: {arr}")

	# Set all elements greater than 2 to zero
	arr[arr > 2] = 0
	print(f"Array after setting elements > 2 to 0: {arr}") # [0 1 2 0 0]

	# Add 100 to all even numbers
	arr_even = np.arange(10)
	arr_even[arr_even % 2 == 0] += 100
	print(f"Array after adding 100 to evens: {arr_even}")
	# [100   1 102   3 104   5 106   7 108   9]
	```

## Related Concepts
- [[NumPy_ndarray]], [[NumPy_Indexing_Slicing]]
- [[NumPy_Conditional_Selection]] (Boolean indexing is the core of this)
- [[NumPy_Broadcasting]] (Boolean masks can be broadcast)
- [[Boolean_Logic]] (Using `&`, `|`, `~` for conditions)
- Filtering data based on conditions

## Questions / Further Study
>[!question] What is special about boolean indexing? (WS_NumPy)
> Several things make boolean indexing special and powerful:
> 1.  **Condition-Based Selection:** It allows selecting data based on complex logical conditions applied to the array's values, rather than just explicit integer indices or slices.
> 2.  **Flexibility:** Conditions can be derived from the array itself or from other compatible arrays. Multiple conditions can be combined using logical operators (`&`, `|`, `~`).
> 3.  **Shape of Result (for N-D arrays):** When a multi-dimensional array is indexed with a boolean array of the *same shape*, the result is a **1D array** containing only the elements where the mask was `True`. This is different from fancy indexing with integer arrays, which can produce results with shapes matching the index array.
> 4.  **Assignment:** It can be used on the left side of an assignment to modify selected elements based on a condition, which is very convenient for conditional updates.
> 5.  **Readability:** Can make code for filtering and conditional selection very concise and readable once understood.

---
**Source:** Worksheet WS_NumPy, NumPy Documentation