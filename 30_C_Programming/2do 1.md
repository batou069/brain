

**File: `30_C_Programming/fgets.md`**
*(Use `T_C_Function.md` template)*

```markdown
---
tags: [c, function, stdio, io, file, stream, input, string]
aliases: []
related: [[stdio_h_C]], [[FILE_pointer_C]], [[fopen]], [[fclose]], [[gets_C]], [[scanf]], [[String_in_C]], [[stdin_stdout_stderr_C]], [[Buffer_Overflow_C]]
worksheet: [C_WS5]
header_file: <stdio.h>
date_created: 2025-04-21
---
# ` fgets() `

## Purpose

The `fgets()` (file get string) function reads a line of text (or at most `n-1` characters) from the specified input stream ([[FILE_pointer_C]]) and stores it into a character array (string buffer). It is generally considered a safer alternative to the deprecated [[gets_C]] function and often preferred over `scanf("%s", ...)` for reading strings because it helps prevent buffer overflows.

## Signature

```c
#include <stdio.h>
char *fgets(char * restrict str, int n, FILE * restrict stream);
```

## Parameters

-   `str`: A pointer (`char*`) to a character array (buffer) where the read string will be stored.
-   `n`: An integer specifying the maximum number of characters to be read (including the null terminator). `fgets` will read at most `n-1` characters from the stream, ensuring space for the null terminator `\0`.
-   `stream`: The `FILE *` pointer identifying the input stream to read from (e.g., `stdin`, or a file opened with [[fopen]]).

## Return Value

-   On **success**, returns the pointer `str`.
-   On **failure** (e.g., end-of-file is reached *before* any characters are read, or a read error occurs), returns `NULL`.
-   If end-of-file is reached *after* some characters have been read, it returns `str` (containing the characters read) but `feof()` will become true for the stream.

## Key Aspects

-   **Line Reading:** Reads characters until either `n-1` characters are read, a newline character (`\n`) is encountered, or the end-of-file (EOF) is reached, whichever comes first.
-   **Newline Handling:** If a newline character (`\n`) is read, it **is stored** in the buffer `str` before the null terminator is added. This is a key difference from `gets`.
-   **Null Termination:** Automatically appends a null terminator (`\0`) after the last character read into the buffer, ensuring the result is always a valid C [[String_in_C|string]].
-   **Buffer Overflow Safety:** By specifying the buffer size `n`, `fgets` prevents writing past the end of the buffer `str`, making it much safer than `gets` or `scanf("%s")`.
-   **Input Source:** Can read from any input stream, including `stdin` (keyboard) or files opened with `fopen`.

## Example Usage

```c
#include <stdio.h>
#include <string.h> // For strcspn

#define BUFFER_SIZE 80

int main() {
    char line_buffer[BUFFER_SIZE];

    // --- Reading from stdin ---
    printf("Enter a line of text (max %d chars):\n", BUFFER_SIZE - 1);

    if (fgets(line_buffer, BUFFER_SIZE, stdin) != NULL) {
        // Optional: Remove trailing newline character if present
        line_buffer[strcspn(line_buffer, "\n")] = '\0';

        printf("You entered: \"%s\"\n", line_buffer);
    } else {
        if (feof(stdin)) {
            printf("End of input reached.\n");
        } else {
            perror("fgets failed on stdin");
        }
        return 1;
    }

    // --- Reading from a file ---
    FILE *fp = fopen("input.txt", "r");
    if (fp == NULL) {
        perror("Error opening input.txt");
        return 1;
    }
    printf("\nReading from input.txt:\n");
    while (fgets(line_buffer, BUFFER_SIZE, fp) != NULL) {
         // Process line (newline is included if read)
         printf("  Read line: %s", line_buffer);
    }
    // Check if loop ended due to EOF or error
    if (ferror(fp)) {
        perror("Error reading from file");
    }
    fclose(fp);


    return 0;
}
// Assumes input.txt exists with some text lines.
```

## Related Functions/Concepts
- [[stdio_h_C]] (Header file)
- [[FILE_pointer_C]] (The input stream)
- [[String_in_C]] (Reads into a C string buffer)
- [[gets_C]] (Deprecated, unsafe predecessor - *to be created*)
- [[scanf]] (Alternative input function, less safe for strings)
- [[fputs]] (Writes a string, often used in conjunction)
- [[stdin_stdout_stderr_C]] (Commonly used with `stdin`)
- [[Buffer_Overflow_C]] (Risk mitigated by `fgets`)
- `feof()`, `ferror()` (Checking stream status after read)

---
**Source:** Worksheet C_WS5
```

**File: `30_C_Programming/fgetc.md`**
*(Use `T_C_Function.md` template)*

```markdown
---
tags: [c, function, stdio, io, file, stream, input, char]
aliases: [getc]
related: [[stdio_h_C]], [[FILE_pointer_C]], [[fopen]], [[fclose]], [[fputc]], [[getchar_C]], [[ungetc_C]], [[File_Handling_C]]
worksheet: [C_WS5]
header_file: <stdio.h>
date_created: 2025-04-21
---
# ` fgetc() `

## Purpose

The `fgetc()` (file get character) function reads the next character from the specified input stream ([[FILE_pointer_C]]) and advances the file position indicator.

## Signature

```c
#include <stdio.h>
int fgetc(FILE *stream);
```

## Parameters

-   `stream`: The `FILE *` pointer identifying the input stream to read from.

## Return Value

-   On **success**, returns the character read, cast to an `int` (as an `unsigned char` value).
-   On **failure** (end-of-file reached or a read error occurs), returns `EOF` (a macro defined in `<stdio.h>`, usually -1).

## Key Aspects

-   **Single Character Input:** Reads one character (byte) at a time.
-   **Return Type `int`:** Returns an `int` to accommodate the special `EOF` value, which is distinct from any valid character value (even if `char` is signed and -1 is a valid `char` value, `EOF` is distinguishable). The return value should be stored in an `int` variable to correctly check for `EOF`.
-   **Advances Position:** Moves the stream's file position indicator to the next character.
-   **Error/EOF Handling:** You must use `feof()` and `ferror()` on the `stream` after receiving `EOF` to determine whether end-of-file was reached or a read error occurred.
-   **`getc()` Macro:** A macro version `getc(stream)` often exists, which may be faster but potentially less safe (e.g., might evaluate `stream` multiple times). `fgetc` is guaranteed to be a function and evaluates `stream` only once.

## Example Usage

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("input.txt", "r");
    if (fp == NULL) {
        perror("Error opening input.txt");
        return 1;
    }

    int character; // Use int to hold return value for EOF check

    printf("Contents of input.txt (character by character):\n");

    // Read characters until EOF is returned
    while ((character = fgetc(fp)) != EOF) {
        // Process the character (here, just print it)
        putchar(character); // putchar takes an int
    }

    // Check why the loop terminated
    if (ferror(fp)) {
        perror("\nError reading file");
    } else if (feof(fp)) {
        printf("\nEnd of file reached.\n");
    }

    fclose(fp);

    return 0;
}
// Assumes input.txt exists.
```

## Related Functions/Concepts
- [[stdio_h_C]] (Header file)
- [[FILE_pointer_C]] (The input stream)
- [[fputc]] (Writes a single character)
- [[getchar_C]] (Equivalent to `fgetc(stdin)`)
- [[fgets]] (Reads a line (string))
- [[fread]] (Reads binary data blocks)
- [[ungetc_C]] (Pushes a character back onto the input stream - *to be created*)
- `EOF` (End-of-file indicator)
- `feof()`, `ferror()` (Checking stream status)

---
**Source:** Worksheet C_WS5
```

**File: `30_C_Programming/fputs.md`**
*(Use `T_C_Function.md` template)*

```markdown
---
tags: [c, function, stdio, io, file, stream, output, string]
aliases: []
related: [[stdio_h_C]], [[FILE_pointer_C]], [[fopen]], [[fclose]], [[puts_C]], [[fgets]], [[fprintf_C]], [[String_in_C]], [[File_Handling_C]]
worksheet: [C_WS5]
header_file: <stdio.h>
date_created: 2025-04-21
---
# ` fputs() `

## Purpose

The `fputs()` (file put string) function writes a [[String_in_C|null-terminated string]] to the specified output stream ([[FILE_pointer_C]]). Unlike its counterpart [[puts_C]], `fputs` does **not** automatically append a newline character (`\n`) to the output.

## Signature

```c
#include <stdio.h>
int fputs(const char * restrict str, FILE * restrict stream);
```

## Parameters

-   `str`: A pointer (`const char*`) to the null-terminated string to be written. The null terminator itself is **not** written to the stream.
-   `stream`: The `FILE *` pointer identifying the output stream to write to.

## Return Value

-   On **success**, returns a non-negative value.
-   On **failure** (e.g., a write error occurs), returns `EOF` (usually -1) and sets the error indicator (`ferror()`) for the stream.

## Key Aspects

-   **String Output:** Writes the sequence of characters from `str` up to, but not including, the terminating null character (`\0`).
-   **No Automatic Newline:** Does not add a `\n` at the end. If a newline is desired, it must be part of the string `str` itself.
-   **Buffered:** Output is typically buffered; use [[fflush]] if immediate writing is required.
-   **Error Handling:** Check the return value against `EOF` and use `ferror()` to confirm if an error occurred.

## Example Usage

```c
#include <stdio.h>

int main() {
    FILE *outfile = fopen("output.log", "w");
    if (outfile == NULL) {
        perror("Error opening output.log");
        return 1;
    }

    char *line1 = "This is the first line.";
    char *line2 = "This is the second line.\n"; // Includes newline

    // Write line1 (no newline added by fputs)
    if (fputs(line1, outfile) == EOF) {
        perror("fputs failed for line1");
        fclose(outfile);
        return 1;
    }

    // Manually add a newline if needed
    fputc('\n', outfile); // Add a newline separately

    // Write line2 (includes its own newline)
    if (fputs(line2, outfile) == EOF) {
        perror("fputs failed for line2");
        fclose(outfile);
        return 1;
    }

    // Write to stdout
    fputs("Message to console (no newline).", stdout);
    fputs(" Still on the same line.\n", stdout); // Add newline here

    printf("Finished writing.\n"); // printf adds newline implicitly via \n

    fclose(outfile);
    return 0;
}
```
**Content of `output.log`:**
```
This is the first line.
This is the second line.
```
**Output to console:**
```
Message to console (no newline). Still on the same line.
Finished writing.
```

## Related Functions/Concepts
- [[stdio_h_C]] (Header file)
- [[FILE_pointer_C]] (The output stream)
- [[String_in_C]] (The data being written)
- [[puts_C]] (Similar function that *does* add a newline, usually writes to `stdout` - *to be created*)
- [[fgets]] (Often used for reading lines that `fputs` might write)
- [[fprintf_C]] (Alternative for writing formatted output, including strings with `%s`)
- [[fwrite]] (For writing binary data, including blocks that might contain strings)
- `EOF`, `ferror()` (Error checking)

---
**Source:** Worksheet C_WS5
```

**File: `30_C_Programming/fputc.md`**
*(Use `T_C_Function.md` template)*

```markdown
---
tags: [c, function, stdio, io, file, stream, output, char]
aliases: [putc]
related: [[stdio_h_C]], [[FILE_pointer_C]], [[fopen]], [[fclose]], [[fgetc]], [[putchar_C]], [[File_Handling_C]]
worksheet: [C_WS5]
header_file: <stdio.h>
date_created: 2025-04-21
---
# ` fputc() `

## Purpose

The `fputc()` (file put character) function writes a single character to the specified output stream ([[FILE_pointer_C]]) and advances the file position indicator.

## Signature

```c
#include <stdio.h>
int fputc(int character, FILE *stream);```

## Parameters

-   `character`: The character to be written. Although declared as an `int`, it is internally converted to an `unsigned char` before being written.
-   `stream`: The `FILE *` pointer identifying the output stream to write to.

## Return Value

-   On **success**, returns the character written (cast back to an `int` as an `unsigned char` value).
-   On **failure** (e.g., a write error occurs), returns `EOF` (usually -1) and sets the error indicator (`ferror()`) for the stream.

## Key Aspects

-   **Single Character Output:** Writes one character (byte) at a time.
-   **Argument Type `int`:** Takes an `int` argument for consistency with `fgetc` (which returns `int` to accommodate `EOF`), but only the `unsigned char` value is actually written.
-   **Advances Position:** Moves the stream's file position indicator past the written character.
-   **Buffered:** Output is typically buffered; use [[fflush]] if immediate writing is required.
-   **Error Handling:** Check the return value against `EOF` and use `ferror()` to confirm if an error occurred.
-   **`putc()` Macro:** A macro version `putc(character, stream)` often exists, which may be faster but potentially less safe (e.g., might evaluate `stream` multiple times). `fputc` is guaranteed to be a function.

## Example Usage

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("chars.txt", "w");
    if (fp == NULL) {
        perror("Error opening chars.txt");
        return 1;
    }

    char *message = "ABC";
    int i = 0;
    int result;

    printf("Writing characters to chars.txt...\n");

    // Write characters from a string one by one
    while (message[i] != '\0') {
        result = fputc(message[i], fp);
        if (result == EOF) {
            perror("fputc failed");
            fclose(fp);
            return 1;
        }
        i++;
    }

    // Write a newline character
    fputc('\n', fp);

    printf("Finished writing.\n");

    fclose(fp);
    return 0;
}
```
**Content of `chars.txt`:**
```
ABC
```

## Related Functions/Concepts
- [[stdio_h_C]] (Header file)
- [[FILE_pointer_C]] (The output stream)
- [[fgetc]] (Reads a single character)
- [[putchar_C]] (Equivalent to `fputc(character, stdout)`)
- [[fputs]] (Writes a string)
- [[fprintf_C]] (Writes formatted output)
- [[fwrite]] (Writes binary data blocks)
- `EOF`, `ferror()` (Error checking)

---
**Source:** Worksheet C_WS5
```

---
### C WS6: Build Process

**File: `30_C_Programming/Header_file_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, module, interface, preprocessor]
aliases: [C Header File, .h File]
related: [[Interface_C]], [[Implementation_C]], [[Function_Declaration_C]], [[struct_C]], [[enum_C]], [[typedef_C]], [[Macro_C]], [[extern_keyword_C]], [[Preprocessor_C]], [[#include_directive_C]], [[Header_Guard_C]], [[Build_Process_C]], [[Compiler_C]], [[Linker_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Header File (`.h`) (C)

## Definition

A **Header File** (conventionally ending with `.h`) in C is a file containing C declarations and macro definitions intended to be shared between multiple source files (`.c` files). Header files define the [[Interface_C|interface]] to a module or library, allowing different parts of a program to use the functions, types, and constants provided by that module without needing access to the implementation details. They are incorporated into source files using the [[Preprocessor_C|preprocessor]] directive [[#include_directive_C|`#include`]].

## Purpose and Content

- **Declare Interfaces:** Provide the public contract for a module.
- **Share Declarations:** Allow functions, types, etc., defined in one `.c` file (the [[Implementation_C]]) to be used correctly by other `.c` files (the clients).
- **Enable Separate Compilation:** Facilitate the standard C [[Build_Process_C|build process]] where source files are compiled independently and then linked together. The compiler only needs the declarations from the header file to compile a client `.c` file correctly.

**Typical Content:**
-   [[Function_Declaration_C|Function declarations (prototypes)]].
-   Type definitions using [[struct_C]], [[union_C]], [[enum_C]], and [[typedef_C]].
-   [[Macro_C|Macro definitions]] (`#define`) for constants or function-like macros.
-   `extern` declarations for global variables that are *defined* in a corresponding `.c` file.

**Content to AVOID:**
-   [[Function_Definition_C|Function definitions]] (except sometimes `inline` functions).
-   [[Variable_Definition_C|Variable definitions]] (definitions allocate memory; defining them in a header included multiple times violates the One Definition Rule).

## Key Aspects

- **`#include` Directive:** Used to insert the content of a header file into a source file before compilation. See [[#include_directive_C]].
- **Header Guards:** Essential mechanism ([[Header_Guard_C]]) using preprocessor directives (`#ifndef`, `#define`, `#endif`) to prevent problems if a header file is accidentally included multiple times within the same compilation unit.
- **Standard Library Headers:** C provides standard headers (e.g., `<stdio.h>`, `<stdlib.h>`, `<string.h>`) containing declarations for standard library functions and types. These are typically included using angle brackets (`#include <header.h>`).
- **Project Headers:** Headers created for the specific project are typically included using double quotes (`#include "myheader.h"`).

## Examples / Use Cases

**`my_module.h` (Header File / Interface):**
```c
#ifndef MY_MODULE_H // Header Guard Start
#define MY_MODULE_H

#include <stddef.h> // Include needed for size_t declaration below

// Define a constant
#define MAX_ITEMS 100

// Define a structure type
typedef struct {
    int id;
    char name[50];
} Item;

// Declare an external global variable (defined in my_module.c)
extern int item_count;

// Declare public functions (defined in my_module.c)
int initialize_module(void);
int add_item(const Item *new_item);
Item* get_item(int id);
size_t get_item_count(void); // Uses size_t from stddef.h

#endif // MY_MODULE_H // Header Guard End
```

**`my_module.c` (Implementation File):**
```c
#include "my_module.h" // Include own header
#include <stdio.h>    // Needed for implementation details (e.g., printf)
#include <stdlib.h>   // Needed for implementation details

// Define the global variable declared as extern in the header
int item_count = 0;

// Internal data (hidden from users of the header)
static Item item_storage[MAX_ITEMS];
static int module_initialized = 0;

// Define public functions
int initialize_module(void) {
    if (module_initialized) return 0; // Already done
    printf("Initializing My Module...\n");
    item_count = 0;
    // ... other setup ...
    module_initialized = 1;
    return 0;
}

int add_item(const Item *new_item) {
    if (!module_initialized) return -1; // Error: not initialized
    if (item_count >= MAX_ITEMS || new_item == NULL) return -1; // Error: full or bad input

    item_storage[item_count] = *new_item; // Copy item
    item_count++;
    return 0; // Success
}

// ... other function definitions ...

size_t get_item_count(void) {
    return (size_t)item_count;
}

Item* get_item(int id) {
    // Dummy implementation
    if (id > 0 && id <= item_count) return &item_storage[id-1];
    return NULL;
}```

**`main.c` (Client File):**
```c
#include <stdio.h>
#include "my_module.h" // Include the interface

int main() {
    if (initialize_module() != 0) {
        fprintf(stderr, "Failed to initialize module.\n");
        return 1;
    }

    Item item1 = {1, "Widget"};
    add_item(&item1);

    printf("Current item count: %zu\n", get_item_count());

    return 0;
}
```

## Related Concepts
- [[Interface_C]], [[Implementation_C]] (Headers define interfaces)
- [[#include_directive_C]], [[Preprocessor_C]] (How headers are used)
- [[Header_Guard_C]] (Essential for preventing multiple inclusions)
- [[Declaration_C]] vs [[Definition_C]] (Headers contain declarations)
- [[Build_Process_C]], [[Compiler_C]], [[Linker_C]] (Headers enable separate compilation)

## Questions / Further Study
>[!question] What should an .h File contain? (WS6)
> See [[Function_Declaration_C]]. Primarily declarations (function prototypes, type definitions, extern variables, macros), not definitions.

>[!question] What .h files should be #include in an .h file? (WS6)
> See [[Function_Declaration_C]]. Only include the minimum headers required for the declarations *within the header itself* to compile. Avoid unnecessary includes.

>[!question] What will happen if you try to include an .h file twice (in the same compilation unit)? (WS6)
> If the header file does **not** have [[Header_Guard_C|header guards]], the compiler will process its contents twice. This can lead to:
> - **Redefinition errors:** If the header defines types (structs, enums, typedefs) or macros, the compiler will complain about redefining them.
> - **Declaration redundancy:** Function prototypes and extern variable declarations might just appear twice, which is usually harmless but messy.
> If the header file **does** have proper header guards, the preprocessor will effectively skip the content on the second and subsequent inclusions within the same compilation unit, preventing redefinition errors.

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Header_Guard_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, preprocessor, header_file, best_practice]
aliases: [C Header Guards, Include Guards]
related: [[Header_file_C]], [[Preprocessor_C]], [[#include_directive_C]], [[#ifndef_directive_C]], [[#define_directive_C]], [[#endif_directive_C]], [[Build_Process_C]], [[Compiler_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Header Guard (C)

## Definition

A **Header Guard**, also known as an **Include Guard**, is a preprocessor construct used in C [[Header_file_C|header files (`.h`)]] to prevent the contents of the header from being included and processed multiple times within a single compilation unit (a single `.c` file after all `#include` directives are processed). This avoids errors caused by duplicate definitions of types, macros, or enums.

## Purpose

- **Prevent Multiple Inclusions:** Ensures that the declarations and definitions within a header file are processed by the [[Compiler_C|compiler]] only once, even if the header is `#include`d multiple times (directly or indirectly through other headers) in the same source file.
- **Avoid Redefinition Errors:** Prevents compiler errors that arise from redefining `struct`s, `union`s, `enum`s, `typedef`s, or macros.

## Common Implementation (`#ifndef` method)

The most common way to implement header guards uses three [[Preprocessor_C|preprocessor]] directives:

1.  **`#ifndef MACRO_NAME`**: (If Not Defined) Checks if a unique macro name (`MACRO_NAME`) has *not* been defined yet. If it hasn't, the preprocessor includes the code between `#ifndef` and the corresponding `#endif`.
2.  **`#define MACRO_NAME`**: If the macro was not defined, this line immediately defines it.
3.  **`#endif // MACRO_NAME`**: Marks the end of the conditional block started by `#ifndef`. A comment indicating the macro name is good practice.

The `MACRO_NAME` must be unique for each header file. A common convention is to base it on the filename, converting to uppercase and replacing non-alphanumeric characters with underscores (e.g., `MY_MODULE_H` for `my_module.h`, or `PROJECT_PATH_MY_MODULE_H` for more uniqueness).

## Example (`my_header.h`)

```c
#ifndef MY_HEADER_H // 1. Check if MY_HEADER_H is NOT defined
#define MY_HEADER_H // 2. If not defined, DEFINE it now

// --- Actual content of the header file ---
#include <stdio.h> // Example: Include needed standard headers

#define MY_CONSTANT 123

typedef struct {
    int data;
} MyStruct;

void my_function(MyStruct *s);
// --- End of actual content ---

#endif // MY_HEADER_H // 3. End of the conditional block
```

**How it Works:**
-   **First Inclusion:** When `my_header.h` is included the first time in a `.c` file, `MY_HEADER_H` is not defined. The `#ifndef` condition is true. `MY_HEADER_H` is then defined, and the header content is processed.
-   **Second (and subsequent) Inclusion:** If the same `.c` file (directly or indirectly) includes `my_header.h` again, `MY_HEADER_H` is now defined. The `#ifndef` condition is false, and the preprocessor skips everything from `#ifndef` down to `#endif`.

## Alternative (`#pragma once`)

Many modern compilers also support a non-standard but widely used directive:

```c
#pragma once

// --- Actual content of the header file ---
// ...
```

`#pragma once` tells the compiler to include the header file only once per compilation unit. It's often simpler to write but less portable than the traditional `#ifndef` guards, although compiler support is now very common.

## Related Concepts
- [[Header_file_C]] (Where guards are used)
- [[Preprocessor_C]] (Processes the guard directives)
- [[#include_directive_C]] (The directive that triggers the need for guards)
- [[#ifndef_directive_C]], [[#define_directive_C]], [[#endif_directive_C]] (Directives used in guards)
- [[Build_Process_C]], [[Compiler_C]] (Guards affect the compilation phase)

## Questions / Further Study
>[!question] What is a header guard? Why is it so important? (WS6)
> A [[Header_Guard_C]] is a preprocessor construct (`#ifndef`/`#define`/`#endif` or `#pragma once`) placed in a [[Header_file_C|header file]] to prevent its contents from being included multiple times within a single compilation unit. It is **critically important** because multiple inclusions of a header without guards lead to compiler errors due to redefinitions of types (structs, enums, typedefs) and macros. Header guards ensure that the declarations are processed only once, maintaining code correctness and enabling modular design with separate compilation.

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Preprocessor_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, compiler, syntax]
aliases: [C Preprocessor]
related: [[Build_Process_C]], [[Compiler_C]], [[Header_file_C]], [[Macro_C]], [[#include_directive_C]], [[#define_directive_C]], [[#ifdef_directive_C]], [[#ifndef_directive_C]], [[#if_directive_C]], [[#else_directive_C]], [[#elif_directive_C]], [[#endif_directive_C]], [[#undef_directive_C]], [[#pragma_directive_C]], [[Conditional_Compilation_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Preprocessor (C)

## Definition

The **C Preprocessor** is a program or phase of the [[Compiler_C|compiler]] that processes the source code *before* the main compilation stage begins. It handles **preprocessor directives**, which are instructions starting with a hash symbol (`#`). The preprocessor modifies the source code based on these directives, performing tasks like text substitution, file inclusion, and conditional compilation. The output of the preprocessor is a modified source code stream (often called a translation unit) that is then fed to the actual compiler.

## Key Tasks and Directives

1.  **File Inclusion (`#include`):**
    -   [[#include_directive_C|`#include <filename.h>`]] or `#include "filename.h"`: Replaces the directive line with the entire content of the specified [[Header_file_C|header file]]. Used to incorporate declarations and macros.

2.  **Macro Definition and Expansion (`#define`, `#undef`):**
    -   [[#define_directive_C|`#define IDENTIFIER replacement_text`]]: Defines an object-like macro. Subsequent occurrences of `IDENTIFIER` (outside strings/comments) are replaced with `replacement_text`.
    -   `#define IDENTIFIER(params...) replacement_text`: Defines a function-like macro. Calls matching the pattern are replaced, with arguments substituted into `replacement_text`.
    -   [[#undef_directive_C|`#undef IDENTIFIER`]]: Removes the definition of a macro.

3.  **Conditional Compilation (`#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`):**
    -   [[Conditional_Compilation_C|Allows sections of code]] to be included or excluded from compilation based on conditions evaluated by the preprocessor (e.g., checking if a macro is defined, comparing constant expressions).
    -   [[#ifdef_directive_C|`#ifdef MACRO`]]: Includes code if `MACRO` is defined.
    -   [[#ifndef_directive_C|`#ifndef MACRO`]]: Includes code if `MACRO` is *not* defined (used for [[Header_Guard_C|header guards]]).
    -   [[#if_directive_C|`#if constant_expression`]]: Includes code if the expression is non-zero.
    -   [[#else_directive_C|`#else`]]: Alternative block for conditional directives.
    -   [[#elif_directive_C|`#elif constant_expression`]]: "Else if" for conditional directives.
    -   [[#endif_directive_C|`#endif`]]: Marks the end of a conditional block.

4.  **Other Directives:**
    -   `#error message`: Causes the preprocessor to issue an error message and stop compilation.
    -   `#warning message`: Causes the preprocessor to issue a warning message (compilation usually continues).
    -   [[#pragma_directive_C|`#pragma directive`]]: Provides implementation-defined instructions to the compiler (e.g., `#pragma once`, optimization hints). Portability varies.
    -   `#line`: Modifies the compiler's internal line number and filename tracking, useful for code generation tools.

## Role in Build Process

The preprocessor is typically the *first* stage in the [[Build_Process_C]]. It takes a `.c` source file, processes all directives (expanding includes, expanding macros, handling conditionals), and outputs a single, expanded source file (often in memory or a temporary file) that the [[Compiler_C]] then parses and translates into assembly or object code.

## Example

**Source (`main.c`):**
```c
#include <stdio.h> // File Inclusion

#define VERSION "1.0" // Object-like Macro
#define SQUARE(x) ((x) * (x)) // Function-like Macro

#ifdef DEBUG
    #define LOG(msg) printf("DEBUG: %s\n", msg)
#else
    #define LOG(msg) // Macro expands to nothing if DEBUG not defined
#endif

int main() {
    printf("Version: %s\n", VERSION); // Macro Expansion
    int num = 5;
    printf("Square of %d is %d\n", num, SQUARE(num)); // Macro Expansion

    LOG("Starting main function."); // Conditional Compilation

    #if __STDC_VERSION__ >= 199901L
        printf("Compiled with C99 or later.\n"); // Conditional Compilation
    #else
        printf("Compiled with pre-C99 standard.\n");
    #endif

    return 0;
}
```

**Preprocessing (Conceptual Output, if compiled with `gcc -DDEBUG ...`):**
```c
// Content of <stdio.h> would be inserted here...

// Macros defined, but not visible in output text unless used

int main() {
    printf("Version: %s\n", "1.0"); // VERSION replaced
    int num = 5;
    printf("Square of %d is %d\n", num, ((num) * (num))); // SQUARE replaced

    printf("DEBUG: %s\n", "Starting main function."); // LOG replaced (DEBUG was defined)

    // Assuming C99 or later
    printf("Compiled with C99 or later.\n"); // #if block included

    return 0;
}
```

## Related Concepts
- [[Build_Process_C]] (Preprocessor is the first stage)
- [[Compiler_C]] (Receives output from the preprocessor)
- [[Header_file_C]], [[#include_directive_C]] (File inclusion)
- [[Macro_C]], [[#define_directive_C]], [[#undef_directive_C]] (Macro handling)
- [[Conditional_Compilation_C]], [[#if_directive_C]], [[#ifdef_directive_C]], etc. (Conditional processing)
- [[Header_Guard_C]] (Implemented using conditional directives)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Compiler_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, tool]
aliases: [C Compiler]
related: [[Build_Process_C]], [[Preprocessor_C]], [[Assembler_C]], [[Linker_C]], [[Source_File_C]], [[Object_File_C]], [[Machine_Code_C]], [[GCC]], [[Clang_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Compiler (C)

## Definition

A **C Compiler** is a specialized computer program that translates source code written in the C programming language into a lower-level language, typically **assembly language** or directly into **machine code** ([[Machine_Code_C]]) that the computer's [[CPU]] can execute. The compiler performs lexical analysis, parsing, semantic analysis, optimization, and code generation. It usually processes one [[Source_File_C|source file (`.c`)]] at a time (after it has been processed by the [[Preprocessor_C]]) to produce a corresponding [[Object_File_C|object file (`.o` or `.obj`)]].

## Role in Build Process

The compiler is a central stage in the C [[Build_Process_C]], typically occurring after preprocessing and before linking:

1.  **[[Preprocessor_C|Preprocessing]]:** Handles `#include`, `#define`, conditional compilation, etc. Output is expanded C code.
2.  **Compilation:** Translates the preprocessed C code into assembly language specific to the target architecture.
3.  **[[Assembler_C|Assembly]]:** Translates the assembly code into relocatable machine code (object code) and stores it in an [[Object_File_C|object file]]. This file contains the translated instructions and data, along with metadata like a [[Symbol_C|symbol table]] (listing defined and undefined functions/variables).
4.  **[[Linker_C|Linking]]:** Combines one or more object files and necessary library code to produce the final executable program.

*(Note: Many compiler toolchains, like [[GCC]], perform the compilation and assembly steps together when invoked unless specifically told otherwise, e.g., using `-S` to stop after generating assembly).*

## Key Tasks

- **Lexical Analysis:** Breaks the source code into tokens (keywords, identifiers, operators, constants, etc.).
- **Syntax Analysis (Parsing):** Checks if the sequence of tokens conforms to the C language grammar, often building an Abstract Syntax Tree (AST).
- **Semantic Analysis:** Checks for type errors, undeclared identifiers, and other meaning-related issues.
- **Optimization:** Applies various transformations to the code (e.g., loop unrolling, constant folding, dead code elimination, register allocation) to improve performance (speed, size). Optimization levels can often be controlled via compiler flags (e.g., `-O0`, `-O1`, `-O2`, `-O3`, `-Os` in GCC/Clang).
- **Code Generation:** Produces the equivalent code in the target language (assembly or machine code).

## Examples of C Compilers

-   **[[GCC]] (GNU Compiler Collection):** A widely used, open-source compiler supporting C, C++, Objective-C, Fortran, Ada, Go, and D. Standard on most Linux systems.
-   **[[Clang_C]]**: A newer compiler front-end (often using the LLVM backend) known for fast compilation and high-quality diagnostics. Compatible with GCC options. Used by Apple (Xcode) and others.
-   **MSVC (Microsoft Visual C++):** The compiler included with Microsoft Visual Studio.
-   **Intel C++ Compiler (ICC/ICX):** Known for generating highly optimized code for Intel processors.

## Related Concepts
- [[Build_Process_C]] (Compiler is a key stage)
- [[Preprocessor_C]] (Provides input to the compiler)
- [[Assembler_C]] (Often invoked by the compiler to process generated assembly)
- [[Linker_C]] (Processes the compiler's output object files)
- [[Source_File_C]] (`.c` files are the primary input)
- [[Object_File_C]] (`.o`/`.obj` files are the primary output)
- [[Assembly_Language_C]] (Intermediate target language - *to be created*)
- [[Machine_Code_C]] (Final target language - *to be created*)
- [[Optimization_C]] (A major task of the compiler - *to be created*)
- [[Symbol_C]] (Generated by the compiler/assembler in object files)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Linker_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, tool]
aliases: [C Linker, Link Editor, ld]
related: [[Build_Process_C]], [[Compiler_C]], [[Object_File_C]], [[Executable_File_C]], [[Static_Library_C]], [[Shared_Library_C]], [[Symbol_C]], [[Symbol_Resolution_C]], [[Relocation_C]], [[Loader_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Linker (C)

## Definition

The **Linker** (or link editor) is a system program that takes one or more [[Object_File_C|object files]] generated by a [[Compiler_C]] or [[Assembler_C]], along with necessary [[Static_Library_C|static libraries]] or references to [[Shared_Library_C|shared libraries]], and combines them to produce a single **executable file**, or sometimes another library or object file.

## Role in Build Process

The linker is typically the *final* stage in the C [[Build_Process_C]] for creating an executable:

1.  Preprocessing
2.  Compilation
3.  Assembly -> Produces Object Files (`.o`)
4.  **Linking:** Combines `.o` files and library code -> Produces Executable File.

## Key Tasks

1.  **[[Symbol_Resolution_C|Symbol Resolution]]:**
    -   Each object file contains a [[Symbol_C|symbol table]] listing the functions and global variables it defines (exports) and those it references but does not define (imports/external symbols).
    -   The linker scans all object files and libraries to find a unique definition for each imported symbol. It associates each reference with exactly one definition.
    -   Errors occur if a symbol is defined multiple times (violating the One Definition Rule, often involving [[Strong_Symbol_C|strong]] vs. [[Weak_Symbol_C|weak]] symbols) or if a referenced symbol cannot be found in any of the provided object files or libraries.

2.  **[[Relocation_C|Relocation]]:**
    -   Object files contain *relocatable* machine code, meaning addresses within the code (e.g., for function calls or global variable access) are often relative or symbolic.
    -   The linker determines the final memory addresses where code and data sections from different object files will reside in the final executable.
    -   It then modifies the machine code, patching the relative or symbolic addresses with the actual absolute or final relative addresses based on the combined layout.

## Inputs and Output

-   **Inputs:**
    -   Object files (`.o`, `.obj`) generated by the compiler/assembler.
    -   Static libraries (`.a`, `.lib`) - Archives of object files. The linker extracts only the needed object files from the archive.
    -   Shared libraries (`.so`, `.dll`, `.dylib`) - The linker usually just records *references* to shared libraries; the actual linking happens at runtime by the [[Loader_C]].
    -   Linker scripts (optional, advanced control over memory layout).
-   **Output:**
    -   An executable file in a format understood by the [[Operating_System]] (e.g., ELF on Linux, PE on Windows, Mach-O on macOS).
    -   Alternatively, can produce a shared library or another relocatable object file.

## Examples

When you compile and link multiple files with GCC:
```bash
# Compile file1.c to file1.o (Preprocessing, Compilation, Assembly)
gcc -c file1.c -o file1.o

# Compile file2.c to file2.o
gcc -c file2.c -o file2.o

# Link file1.o and file2.o (and standard C library implicitly) to create executable 'my_program'
# The 'gcc' command here invokes the linker (usually 'ld') behind the scenes.
gcc file1.o file2.o -o my_program
```

## Related Concepts
- [[Build_Process_C]] (Linker is the final stage for executables)
- [[Compiler_C]], [[Assembler_C]] (Produce input for the linker)
- [[Object_File_C]] (Primary input)
- [[Executable_File_C]] (Primary output - *to be created*)
- [[Static_Library_C]], [[Shared_Library_C]] (Provide reusable code)
- [[Symbol_C]], [[Symbol_Resolution_C]], [[Relocation_C]] (Core tasks of the linker)
- [[Strong_Symbol_C]], [[Weak_Symbol_C]] (Affect symbol resolution)
- [[Loader_C]] (Handles loading the executable and runtime linking for shared libraries)
- One Definition Rule (ODR) (Enforced by the linker)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Loader_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, os, execution, memory]
aliases: [C Loader, Program Loader]
related: [[Build_Process_C]], [[Linker_C]], [[Executable_File_C]], [[Operating_System]], [[Memory_Management]], [[Virtual_memory]], [[Shared_Library_C]], [[Dynamic_Linking_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Loader (C Program Execution)

## Definition

The **Loader** is a part of the [[Operating_System]] responsible for preparing an [[Executable_File_C|executable file]] (generated by the [[Linker_C]]) to run. It loads the program's machine code and data from the executable file on disk into the computer's main memory ([[RAM]]), performs necessary setup, and transfers control to the program's entry point (usually starting the execution of the [[main_Function_C|`main` function]] indirectly via runtime startup code).

## Role in Execution

The loader operates *after* the [[Build_Process_C]] is complete and *when* the user or another process requests to execute the program.

1.  User/OS initiates program execution (e.g., typing `./myprogram` in the shell).
2.  The OS invokes the loader.
3.  **Loader performs tasks:**
    *   Reads the executable file header to determine memory layout, required libraries, entry point, etc.
    *   Allocates virtual address space for the new [[Process]].
    *   Maps sections of the executable file (like [[Code_Segment_C|code]] and initialized [[Data_Segment_C|data]]) from disk into the allocated virtual memory space. May use demand paging (loading pages only when accessed).
    *   Allocates and initializes the [[BSS_Segment_C|BSS segment]] (uninitialized data) to zeros.
    *   Allocates space for the [[Stack_Memory_C|stack]] and potentially the initial [[Heap_Memory_C|heap]].
    *   Loads any required [[Shared_Library_C|shared libraries]] into the process's address space (Dynamic Linking). This might involve further relocation steps performed by the dynamic linker/loader (`ld.so` on Linux). See [[Dynamic_Linking_C]].
    *   Performs final address relocations if necessary (especially for position-independent executables or shared libraries).
    *   Sets up arguments (`argc`, `argv`) and environment variables (`envp`) for the `main` function, typically on the stack.
    *   Transfers control to the program's entry point (often a small runtime startup routine in the C library, like `_start`, which initializes the standard library and then calls the program's `main` function).

## Key Tasks

- **Loading:** Copying code and data from executable file to memory.
- **Memory Allocation:** Setting up the process's virtual address space (code, data, BSS, stack, heap).
- **Dynamic Linking:** Loading shared libraries and resolving symbols at runtime (often delegated to a dynamic linker).
- **Initialization:** Setting up `argc`/`argv`/`envp`, calling runtime startup code.
- **Starting Execution:** Transferring control to the program's entry point.

## Related Concepts
- [[Build_Process_C]] (Loader acts on the output of the build process)
- [[Linker_C]] (Creates the executable file read by the loader)
- [[Executable_File_C]] (The input file for the loader)
- [[Operating_System]] (The loader is part of the OS)
- [[Memory_Management]], [[Virtual_memory]] (Loader manages process memory space)
- [[Memory_Segments_C]] (Code, Data, BSS, Stack, Heap are set up by the loader)
- [[Shared_Library_C]], [[Dynamic_Linking_C]] (Loader handles shared libraries at runtime)
- [[Process]] (Loader creates the memory image for a new process)
- [[main_Function_C]] (The ultimate target function called after loader setup)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Memory_Segments_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, execution, process, build_process]
aliases: [C Memory Layout, Process Memory Segments]
related: [[Memory_Management]], [[Process]], [[Loader_C]], [[Linker_C]], [[Code_Segment_C]], [[Data_Segment_C]], [[BSS_Segment_C]], [[Heap_Memory_C]], [[Stack_Memory_C]], [[Static_Variable_C]], [[Global_Variable_C]], [[Automatic_Variable_C]], [[Dynamic_Allocation_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Memory Segments (C Process Layout)

## Definition

When a C program is loaded into memory and executed as a [[Process]], its virtual address space is typically organized by the [[Operating_System]] and [[Loader_C]] into several distinct regions or **segments**, each serving a specific purpose. While the exact layout can vary depending on the OS and architecture, common segments include the Code Segment, Data Segment, BSS Segment, Heap, and Stack.

## Common Segments

1.  **[[Code_Segment_C|Code Segment (.text)]]:**
    -   Contains the compiled machine code instructions of the program.
    -   Usually marked as read-only and executable by the OS to prevent accidental modification or code injection attacks.
    -   Size is fixed at compile/link time.

2.  **[[Data_Segment_C|Data Segment (.data)]]:**
    -   Contains **initialized** global variables and static variables (both global and local).
    -   Initial values are read from the executable file.
    -   Read-write memory.
    -   Size is fixed at compile/link time.
    -   Sometimes split into read-only data (`.rodata` for constants like string literals) and read-write data (`.data`).

3.  **[[BSS_Segment_C|BSS Segment (.bss)]]:**
    -   (Block Started by Symbol) Contains **uninitialized** (or zero-initialized) global variables and static variables.
    -   The [[Loader_C]] allocates this memory and initializes it to all zero bits when the program starts.
    -   Doesn't take up space in the executable file itself (only its size is stored), saving disk space.
    -   Read-write memory.
    -   Size is fixed at compile/link time.

4.  **[[Heap_Memory_C|Heap]]:**
    -   Region used for [[Dynamic_Allocation_C|dynamic memory allocation]] ([[malloc]], [[calloc_C]], [[realloc_C]]).
    -   Managed by the C library's memory allocator.
    -   Grows and shrinks during program execution as memory is allocated and freed. Typically grows upwards (towards higher addresses) from the end of the BSS/Data segments.
    -   Read-write memory.

5.  **[[Stack_Memory_C|Stack]]:**
    -   Used for [[Automatic_Variable_C|automatic (local) variables]], function parameters, return addresses, and function call bookkeeping (stack frames).
    -   Grows and shrinks automatically as functions are called and return (LIFO - Last-In, First-Out). Typically grows downwards (towards lower addresses) from a high address.
    -   Read-write memory.
    -   Size is usually limited; exceeding it causes a [[Stack_Overflow_C]].

## Conceptual Layout (Typical Linux/Unix)

```
+-----------------------+ <-- High Address
| Environment Variables |
| Command Line Args     |
| (argc, argv)          |
+-----------------------+
|         Stack         | Grows Downwards V
|-----------------------|
|                       |
|          ...          | (Unallocated Space)
|                       |
|-----------------------|
|          Heap         | Grows Upwards   ^
|-----------------------|
|          BSS          | (Uninitialized global/static data)
|-----------------------|
|         Data          | (Initialized global/static data)
|-----------------------|
|         Text          | (Code / Instructions) Read-Only
+-----------------------+ <-- Low Address (Often near 0, but protected)
```

## Related Concepts
- [[Process]] (Segments define the process address space)
- [[Loader_C]] (Sets up the segments)
- [[Linker_C]] (Determines sizes and content for Code, Data, BSS)
- [[Code_Segment_C]], [[Data_Segment_C]], [[BSS_Segment_C]], [[Heap_Memory_C]], [[Stack_Memory_C]] (Individual segments)
- [[Static_Variable_C]], [[Global_Variable_C]] (Stored in Data/BSS)
- [[Automatic_Variable_C]] (Stored on Stack)
- [[Dynamic_Allocation_C]] (Uses Heap)
- [[Virtual_memory]] (The underlying OS mechanism managing these segments)

## Questions / Further Study
>[!question] For `char str1[20]; char *str2 = malloc(...); char *str3 = "whatever"; char str4[] = "whatever";` inside a function, what are the segment, allocation, and initialization differences? (WS6)
> Assuming these are defined inside a function `Foo()`:
> 1.  **`char str1[20];`**
>     -   **Segment:** [[Stack_Memory_C|Stack]]. It's an automatic local array.
>     -   **Allocation:** Automatic, occurs when `Foo` is entered. Space for 20 chars allocated on the stack frame. Deallocated when `Foo` exits.
>     -   **Initialization:** **None** (contains garbage values).
> 2.  **`char *str2 = malloc(sizeof(*str2) * 20);`**
>     -   **Segment:**
>         -   `str2` (the pointer variable itself): [[Stack_Memory_C|Stack]] (it's an automatic local variable).
>         -   Memory block pointed to by `str2`: [[Heap_Memory_C|Heap]].
>     -   **Allocation:**
>         -   `str2`: Automatic (when `Foo` entered).
>         -   Memory block: Dynamic (at runtime via [[malloc]]). Persists until explicitly [[free|freed]].
>     -   **Initialization:**
>         -   `str2`: Initialized with the address returned by `malloc` (or `NULL` if malloc fails).
>         -   Memory block: **None** (contains garbage values).
> 3.  **`char *str3 = "whatever";`**
>     -   **Segment:**
>         -   `str3` (the pointer variable itself): [[Stack_Memory_C|Stack]] (automatic local variable).
>         -   String literal `"whatever"`: Typically stored in a read-only data segment (e.g., `.rodata`, part of or related to the [[Code_Segment_C]] or [[Data_Segment_C]]).
>     -   **Allocation:**
>         -   `str3`: Automatic (when `Foo` entered).
>         -   String literal: Static (allocated by the compiler/linker as part of the program image). Exists for program lifetime.
>     -   **Initialization:**
>         -   `str3`: Initialized with the starting address of the string literal `"whatever"`.
>         -   String literal: Initialized at compile/link time with the characters 'w','h','a','t','e','v','e','r','\0'.
> 4.  **`char str4[] = "whatever";`**
>     -   **Segment:** [[Stack_Memory_C|Stack]]. It's an automatic local array.
>     -   **Allocation:** Automatic (when `Foo` entered). Size is 9 bytes (for "whatever" + `\0`). Deallocated when `Foo` exits.
>     -   **Initialization:** Initialized when `Foo` is entered by **copying** the characters from the string literal `"whatever"` (including `\0`) into the stack-allocated array `str4`. The array `str4` itself is modifiable.

>[!question] What will happen if we add `str3[1] = 'a';`? How can you change the program so this won't compile? (WS6)
> - **What happens:** `str3[1] = 'a';` attempts to modify the second character ('h') of the string literal `"whatever"`. Since string literals are typically stored in read-only memory, this results in **[[Undefined_Behavior_C]]**, which most often manifests as a runtime crash (segmentation fault).
> - **Prevent Compilation:** You can make the compiler issue an error (or at least a warning that's often treated as an error with flags like `-Werror`) by declaring the pointer as pointing to *constant* characters:
>   ```c
>   const char *str3 = "whatever";
>   // Now, str3[1] = 'a'; will cause a compile-time error:
>   // error: assignment of read-only location '*(str3 + 1)'
>   ```
>   Using `const` correctly reflects the fact that string literals should not be modified through pointers pointing to them.

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Code_Segment_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, execution, process, build_process, segment]
aliases: [C Code Segment, Text Segment, .text]
related: [[Memory_Segments_C]], [[Machine_Code_C]], [[Compiler_C]], [[Linker_C]], [[Loader_C]], [[Process]], [[Read_Only_Memory_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Code Segment (`.text`) (C)

## Definition

The **Code Segment**, often referred to as the **Text Segment** or `.text` section in object file formats like ELF, is the region in a program's virtual address space ([[Memory_Segments_C]]) where the executable machine code instructions reside.

## Key Aspects / Characteristics

- **Contains Instructions:** Holds the actual [[Machine_Code_C]] generated by the [[Compiler_C]] and [[Assembler_C]] from the program's source code (functions).
- **Read-Only:** Typically marked as read-only by the [[Operating_System]]'s memory management unit (MMU) after being loaded by the [[Loader_C]]. This prevents accidental or malicious modification of the program's instructions during execution, enhancing stability and security.
- **Executable:** Marked as executable, allowing the [[CPU]] to fetch and execute instructions from this memory region.
- **Fixed Size:** The size of the code segment is determined at compile/link time by the [[Linker_C]] and does not change during program execution.
- **Shared (Potentially):** If multiple processes run the same program, the operating system can often map the same physical read-only code segment pages into the virtual address space of each process, saving physical memory.
- **Location:** Usually located at one of the lower virtual memory addresses in the process layout.

## Related Concepts
- [[Memory_Segments_C]] (Code segment is one part of the layout)
- [[Machine_Code_C]] (The content of the code segment)
- [[Compiler_C]], [[Linker_C]], [[Loader_C]] (Tools involved in creating and loading the segment)
- [[Process]] (The running entity whose memory includes this segment)
- [[Read_Only_Memory_C]] (The typical memory protection attribute)
- [[Data_Segment_C]], [[BSS_Segment_C]], [[Heap_Memory_C]], [[Stack_Memory_C]] (Other memory segments)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Data_Segment_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, execution, process, build_process, segment]
aliases: [C Data Segment, Initialized Data Segment, .data, .rodata]
related: [[Memory_Segments_C]], [[Static_Variable_C]], [[Global_Variable_C]], [[BSS_Segment_C]], [[Compiler_C]], [[Linker_C]], [[Loader_C]], [[Process]], [[String_Literal_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Data Segment (`.data`, `.rodata`) (C)

## Definition

The **Data Segment** refers to the portion(s) of a program's virtual address space ([[Memory_Segments_C]]) that contain **initialized** static and global variables. These are variables whose initial values are known at compile time and are stored directly within the executable file.

## Key Aspects / Characteristics

- **Initialized Static/Global Data:** Stores global variables and static variables (both global and local) that are explicitly initialized with non-zero values (or non-NULL for pointers, etc.).
- **Read from Executable:** The initial values for this segment are stored in the executable file created by the [[Linker_C]] and are loaded into memory by the [[Loader_C]] when the program starts.
- **Fixed Size:** The size of the data segment is determined at compile/link time and does not change during program execution.
- **Sub-Segments (Common):** Often split into two parts:
    - **`.data` (Initialized Read-Write Data):** Contains initialized global/static variables that *can* be modified during runtime.
        - Example: `int global_counter = 10;`
    - **`.rodata` (Read-Only Data):** Contains initialized global/static data that should *not* be modified. The OS typically marks this section as read-only in memory.
        - Example: `const char *message = "Hello";` (The pointer `message` might be in `.data` or on stack if local, but the string literal `"Hello"` itself is in `.rodata`).
        - Example: `const int lookup_table[] = {1, 1, 2, 3, 5};` (if declared globally or static).
- **Location:** Usually located adjacent to the [[Code_Segment_C]] in the process memory layout.

## Examples

```c
#include <stdio.h>

// Stored in .data (initialized read-write)
int initialized_global = 99;
static int initialized_static_global = 10;

// Stored in .rodata (read-only)
const char * greeting = "Welcome";
const float PI = 3.14159;

// Stored in .bss (uninitialized) - NOT in data segment
int uninitialized_global;
static int uninitialized_static_global;

void func() {
    // Stored in .data (initialized read-write, initialized only once)
    static int local_static_initialized = 1;
    local_static_initialized++;
    printf("  local_static_initialized = %d\n", local_static_initialized);
}

int main() {
    printf("initialized_global = %d\n", initialized_global);
    printf("greeting = %s\n", greeting);
    // greeting[0] = 'W'; // ERROR or Undefined Behavior (modifying .rodata)
    initialized_global = 100; // OK (modifying .data)

    func();
    func();

    return 0;
}
```

## Related Concepts
- [[Memory_Segments_C]] (Data segment is one part of the layout)
- [[Static_Variable_C]], [[Global_Variable_C]] (Variables stored here)
- [[BSS_Segment_C]] (Segment for *uninitialized* static/global data)
- [[Code_Segment_C]], [[Heap_Memory_C]], [[Stack_Memory_C]] (Other memory segments)
- [[Compiler_C]], [[Linker_C]], [[Loader_C]] (Tools involved in creating and loading the segment)
- [[Process]] (The running entity whose memory includes this segment)
- [[String_Literal_C]] (Often stored in `.rodata` - *to be created*)
- `const` keyword (Often used for data placed in `.rodata`)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Stack_Segment_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, execution, process, segment]
aliases: [C Stack Segment]
related: [[Memory_Segments_C]], [[Stack_Memory_C]], [[Automatic_Variable_C]], [[Local_Variable_C]], [[Function_Call_C]], [[Function_Parameters_C]], [[Return_Address_C]], [[Stack_Frame_C]], [[Stack_Overflow_C]], [[Loader_C]], [[Operating_System]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Stack Segment (C)

## Definition

The **Stack Segment**, commonly referred to simply as **The Stack**, is a region of memory ([[Memory_Segments_C]]) within a process's address space that is used for storing temporary data associated with [[Function_Call_C|function calls]]. It operates in a Last-In, First-Out (LIFO) manner.

*(Note: This describes the call stack used for function execution, distinct from abstract data structure "stack")*

## Key Aspects / Characteristics

- **Function Call Management:** Used primarily to manage data related to active function calls.
- **Stack Frames:** When a function is called, a new **stack frame** (or activation record) is typically pushed onto the stack. When the function returns, its frame is popped off. See [[Stack_Frame_C]].
- **Contents of a Stack Frame:** A stack frame usually contains:
    - [[Function_Parameters_C|Function arguments]] passed to the function.
    - [[Automatic_Variable_C|Automatic (local) variables]] declared within the function.
    - [[Return_Address_C|Return address]]: The address in the calling function's code to return to when the current function finishes.
    - Saved state from the calling function (e.g., previous frame pointer, saved registers).
- **LIFO Structure:** The last function called is the first one to return; its frame is the topmost and the first to be removed.
- **Automatic Allocation/Deallocation:** Memory management on the stack is automatic and very fast, typically involving only adjustments to a stack pointer register by the [[CPU]]. Memory is allocated when a function/block is entered and deallocated when it exits.
- **Fixed Size (Typically):** The total size allocated for the stack segment by the [[Operating_System]] or [[Loader_C]] is usually fixed (though it can sometimes be adjusted).
- **Stack Overflow:** If function calls nest too deeply (e.g., deep [[Recursion_C]]) or if very large automatic variables are declared, the stack can run out of space, leading to a [[Stack_Overflow_C|stack overflow]] error, which usually crashes the program.
- **Location:** Typically located at the higher end of the process's virtual address space and grows downwards towards lower addresses.

## Examples

```c
#include <stdio.h>

void func_b(int b_param) {
    int b_local = b_param * 2; // b_local on func_b's stack frame
    printf("  In func_b: b_param=%d, b_local=%d\n", b_param, b_local);
    // Return address to func_a is also on the stack
} // func_b's stack frame is popped

void func_a(int a_param) {
    int a_local = a_param + 5; // a_local on func_a's stack frame
    printf(" In func_a: a_param=%d, a_local=%d\n", a_param, a_local);
    func_b(a_local); // Push func_b's frame
    printf(" Back in func_a\n");
    // Return address to main is also on the stack
} // func_a's stack frame is popped

int main() {
    int main_var = 10; // main_var on main's stack frame
    printf("In main: main_var=%d\n", main_var);
    func_a(main_var); // Push func_a's frame
    printf("Back in main\n");
    return 0;
} // main's stack frame is popped
```
**Conceptual Stack Growth:**
1. `main` called: `main` frame pushed (`main_var`, return addr to OS).
2. `func_a` called: `func_a` frame pushed (`a_param`, `a_local`, return addr to `main`).
3. `func_b` called: `func_b` frame pushed (`b_param`, `b_local`, return addr to `func_a`).
4. `func_b` returns: `func_b` frame popped. Control returns to `func_a`.
5. `func_a` returns: `func_a` frame popped. Control returns to `main`.
6. `main` returns: `main` frame popped. Control returns to OS.

## Related Concepts
- [[Memory_Segments_C]] (Stack is one segment)
- [[Stack_Memory_C]] (Synonym for the memory region)
- [[Automatic_Variable_C]], [[Local_Variable_C]] (Stored on the stack)
- [[Function_Call_C]], [[Function_Parameters_C]], [[Return_Address_C]] (Managed via the stack)
- [[Stack_Frame_C]] (Unit of allocation on the stack per function call - *to be created*)
- [[30_C_Programming/Stack_Overflow_C]] (Error condition)
- [[Heap_Memory_C]] (Contrasted with stack: dynamic, manual management)
- [[Recursion_C]] (Can consume stack space rapidly)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Heap_Segment_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, execution, process, segment, alias]
aliases: [C Heap Segment]
related: [[Memory_Segments_C]], [[Heap_Memory_C]], [[Dynamic_Allocation_C]], [[malloc]], [[free]], [[Process]], [[Loader_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Heap Segment (C)

## Definition

The **Heap Segment**, commonly referred to simply as **The Heap**, is the region within a process's virtual address space ([[Memory_Segments_C]]) dedicated to [[Dynamic_Allocation_C|dynamic memory allocation]].

*(Note: This is largely synonymous with [[Heap_Memory_C]]. This note focuses on its role as a distinct segment in the process memory layout).*

## Key Aspects / Characteristics

- **Dynamic Memory Area:** The primary pool of memory from which [[malloc]], [[calloc_C]], and [[realloc_C]] allocate blocks at runtime.
- **Location:** Typically located in the process address space above the [[BSS_Segment_C]] and [[Data_Segment_C]].
- **Growth:** Usually grows upwards towards higher memory addresses as more memory is requested via allocation functions. The actual mechanism involves the memory allocator requesting larger chunks of virtual memory from the [[Operating_System]] (e.g., using `brk` or `mmap` system calls on Linux) and managing these chunks internally.
- **Managed by Allocator:** Not directly managed by the compiler or CPU stack pointer like the [[Stack_Segment_C]]. Management (finding free blocks, handling fragmentation, coalescing freed blocks) is done by the C standard library's memory allocator routines linked into the program.
- **Lifetime Control:** Memory allocated here persists until explicitly deallocated with [[free]]. Its lifetime is independent of function call scopes.
- **Size:** The maximum size of the heap can be large, limited by the available virtual address space and system resources, unlike the typically more constrained [[Stack_Segment_C]].

## Related Concepts
- [[Memory_Segments_C]] (Heap is one segment)
- [[Heap_Memory_C]] (Synonym for the memory region)
- [[Dynamic_Allocation_C]] (The process using the heap)
- [[malloc]], [[free]], [[calloc_C]], [[realloc_C]] (Functions managing heap memory)
- [[Stack_Segment_C]] (Contrasted with heap)
- [[Data_Segment_C]], [[BSS_Segment_C]], [[Code_Segment_C]] (Other segments)
- [[Process]] (The running entity whose memory includes the heap)
- [[Loader_C]], [[Operating_System]] (Involved in initially setting up the heap area)
- [[Memory_Leak_C]], Heap Fragmentation (Potential issues with heap management)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/BSS_Segment_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, execution, process, build_process, segment]
aliases: [C BSS Segment, .bss, Uninitialized Data Segment]
related: [[Memory_Segments_C]], [[Data_Segment_C]], [[Static_Variable_C]], [[Global_Variable_C]], [[Compiler_C]], [[Linker_C]], [[Loader_C]], [[Process]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# BSS Segment (`.bss`) (C)

## Definition

The **BSS (Block Started by Symbol) Segment**, often referred to as the `.bss` section, is the portion of a program's virtual address space ([[Memory_Segments_C]]) that contains **uninitialized** (or implicitly zero-initialized) global variables and static variables (both global and local).

## Key Aspects / Characteristics

- **Uninitialized/Zero-Initialized Static/Global Data:** Stores global and static variables that were *not* explicitly initialized in the source code, or were explicitly initialized to zero.
- **Zero Initialization at Load Time:** The key feature is that the actual zero values are **not** stored in the executable file on disk. Only the *size* of the BSS segment is recorded in the executable. When the program is loaded by the [[Loader_C]], the operating system allocates memory for the BSS segment and initializes it entirely to zero bits before the program starts executing.
- **Saves Executable Size:** By not storing large blocks of zeros in the executable file, the BSS segment significantly reduces the size of the program file on disk compared to storing all zero-initialized variables in the [[Data_Segment_C]].
- **Read-Write Memory:** Like the `.data` segment, the BSS segment resides in read-write memory, allowing the variables stored within it to be modified during program execution.
- **Fixed Size:** The size of the BSS segment is determined at compile/link time by the [[Linker_C]] based on the declarations of uninitialized static/global variables.
- **Location:** Usually located adjacent to the [[Data_Segment_C]] in the process memory layout.

## Examples

```c
#include <stdio.h>

// Stored in .bss (implicitly zero-initialized)
int global_bss_var;
static int static_global_bss_var;
double large_bss_array[1000]; // Takes space in BSS, not in executable file

// Stored in .data (explicitly initialized non-zero)
int global_data_var = 10;

void func() {
    // Stored in .bss (implicitly zero-initialized, only once)
    static int local_static_bss_var;
    local_static_bss_var++;
    printf("  local_static_bss_var = %d\n", local_static_bss_var);
}

int main() {
    printf("global_bss_var = %d\n", global_bss_var); // Output: 0
    printf("static_global_bss_var = %d\n", static_global_bss_var); // Output: 0
    printf("large_bss_array[500] = %f\n", large_bss_array[500]); // Output: 0.000000

    func(); // local_static_bss_var becomes 1
    func(); // local_static_bss_var becomes 2

    return 0;
}
```

## Related Concepts
- [[Memory_Segments_C]] (BSS is one segment)
- [[Data_Segment_C]] (Segment for *initialized* static/global data)
- [[Static_Variable_C]], [[Global_Variable_C]] (Variables stored here if uninitialized)
- [[Code_Segment_C]], [[Heap_Memory_C]], [[Stack_Memory_C]] (Other memory segments)
- [[Compiler_C]], [[Linker_C]] (Determine BSS size)
- [[Loader_C]] (Allocates and zero-initializes BSS at runtime)
- [[Process]] (The running entity whose memory includes this segment)
- Initialization (Implicit zero-initialization is key)

## Questions / Further Study
>[!question] What is the BSS? What is stored in the BSS, and how? (WS6)
> The [[BSS_Segment_C|BSS]] (Block Started by Symbol) is a memory segment in a C program's address space.
> - **What is stored:** It stores **uninitialized** (or zero-initialized) global variables and static variables (both global and local).
> - **How:** The actual zero values are *not* stored in the executable file. Only the total size required for these variables is recorded. When the program [[Loader_C|loader]] starts the program, it allocates a block of memory of the required size for the BSS segment and fills it entirely with zeros before `main` is called. This saves space in the executable file compared to storing large blocks of zeros explicitly in the [[Data_Segment_C]].

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Symbol_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, linker, compiler, object_file]
aliases: [C Symbol, Linker Symbol]
related: [[Linker_C]], [[Compiler_C]], [[Object_File_C]], [[Symbol_Resolution_C]], [[Strong_Symbol_C]], [[Weak_Symbol_C]], [[Symbol_Table_C]], [[Function_C]], [[Global_Variable_C]], [[Static_Function_C]], [[Static_Variable_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Symbol (C Build Process)

## Definition

In the context of C compilation and linking, a **Symbol** is a name used to identify a defined entity, such as a [[Function_C]] or a global variable ([[Global_Variable_C]]), within an [[Object_File_C|object file]] or executable. Symbols allow different code modules (object files, libraries) to refer to each other. The [[Linker_C]] uses symbols to resolve these references and combine the modules correctly.

## Key Aspects / Characteristics

- **Identification:** Provides a name for functions and global variables.
- **Symbol Table:** Compilers and assemblers generate a [[Symbol_Table_C]] within each object file, listing the symbols defined or referenced by that file.
- **Types of Symbols:**
    - **Defined Global Symbols:** Functions and global variables defined in the current module and intended to be accessible by other modules (External Linkage). These are "exported" by the object file.
    - **External Symbols (Imports):** Symbols referenced (used) in the current module but defined in another module. The linker needs to find the definition elsewhere.
    - **Local Symbols:** Symbols defined within the current module but not intended for use by other modules (Internal Linkage), such as [[Static_Function_C|static functions]] and [[Static_Variable_C|static global variables]]. These are often included in the symbol table for debugging but are not used for linking across modules.
- **Linker's Role:** The linker performs [[Symbol_Resolution_C]], matching external symbol references in one file with defined global symbols in another.
- **Strong vs. Weak:** Symbols can be classified as [[Strong_Symbol_C|strong]] (typically functions and initialized global variables) or [[Weak_Symbol_C|weak]] (typically uninitialized global variables). These classifications affect how the linker handles multiple definitions.

## Examples

Consider two files:

**`math_utils.c`:**
```c
int global_count = 0; // Defined Global Symbol (Strong)

int add(int a, int b) { // Defined Global Symbol (Strong)
    global_count++;
    return a + b;
}
```

**`main.c`:**
```c
#include <stdio.h>

// External Symbol References (defined elsewhere)
extern int global_count;
extern int add(int, int);

int main() {
    int result = add(5, 3); // Reference to external symbol 'add'
    printf("Result: %d\n", result);
    printf("Count: %d\n", global_count); // Reference to external symbol 'global_count'
    return 0;
}```

- When `math_utils.c` is compiled to `math_utils.o`, its symbol table will list `global_count` and `add` as defined global symbols.
- When `main.c` is compiled to `main.o`, its symbol table will list `global_count` and `add` as external symbols (undefined here) and `main` as a defined global symbol.
- The [[Linker_C]] takes `main.o` and `math_utils.o`. It resolves the external references in `main.o` by finding the definitions in `math_utils.o`.

## Related Concepts
- [[Linker_C]] (Uses symbols for resolution and relocation)
- [[Compiler_C]], [[Assembler_C]] (Generate symbols and symbol tables)
- [[Object_File_C]], [[Executable_File_C]] (Contain symbol tables)
- [[Symbol_Resolution_C]] (The process of matching references to definitions)
- [[Symbol_Table_C]] (The data structure listing symbols - *to be created*)
- [[Strong_Symbol_C]], [[Weak_Symbol_C]] (Symbol types affecting linking)
- [[Function_C]], [[Global_Variable_C]] (Common sources of defined global symbols)
- [[Static_Function_C]], [[Static_Variable_C]] (Common sources of local symbols)
- [[nm_command]], [[objdump_command]] (Tools to inspect symbols in object files/executables)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Strong_Symbol_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, linker, symbol]
aliases: [C Strong Symbol]
related: [[Symbol_C]], [[Weak_Symbol_C]], [[Linker_C]], [[Symbol_Resolution_C]], [[Function_C]], [[Global_Variable_C]], [[Definition_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Strong Symbol (C Linker)

## Definition

In the context of the C [[Linker_C]], a **Strong Symbol** refers to a [[Symbol_C]] that has a "strong" definition, typically corresponding to:

1.  Defined [[Function_C|functions]].
2.  [[Global_Variable_C|Global variables]] that are explicitly initialized.

The distinction between strong and [[Weak_Symbol_C|weak]] symbols is crucial for how the linker handles multiple definitions of the same global symbol during [[Symbol_Resolution_C]].

## Linker Rules (Strong vs. Weak)

The linker generally follows these rules when resolving global symbols:

1.  **Multiple strong symbols with the same name are not allowed.** This results in a linker error (violating the One Definition Rule).
2.  **Given one strong symbol and multiple weak symbols with the same name, choose the strong symbol.** References to the symbol resolve to the strong definition.
3.  **Given multiple weak symbols with the same name, pick one of the weak symbols arbitrarily.** The choice might depend on the linker or the order of files/libraries. This can lead to subtle bugs if the different weak definitions are not truly equivalent (e.g., different sizes for uninitialized arrays).

## Examples

```c
// --- File1.c ---
#include <stdio.h>

// Strong symbol (initialized global variable)
int strong_var = 10;

// Strong symbol (function definition)
void strong_func() {
    printf("Strong func in File1\n");
}

// Weak symbol (uninitialized global variable)
int weak_var; // Implicitly initialized to 0, treated as weak

// --- File2.c ---
#include <stdio.h>

// extern int strong_var; // Reference
// extern void strong_func(); // Reference
// extern int weak_var; // Reference

// Attempting to redefine a strong symbol -> LINKER ERROR
// int strong_var = 20; // ERROR: Multiple definition of 'strong_var'
// void strong_func() { printf("Oops\n"); } // ERROR: Multiple definition of 'strong_func'

// Defining a weak symbol again (allowed, but linker picks one)
int weak_var; // Another weak definition

// Defining a strong symbol where only weak existed before (OK)
// int weak_var = 100; // This would make 'weak_var' strong in File2

int main() {
    strong_func(); // Calls the one in File1
    printf("strong_var = %d\n", strong_var); // Uses the one from File1
    printf("weak_var = %d\n", weak_var); // Uses one of the weak definitions (will be 0)
    return 0;
}
```
**Linking `gcc file1.c file2.c -o main`:**
- The linker sees `strong_var` defined strongly in `file1.c`. References in `file2.c` resolve to this.
- The linker sees `strong_func` defined strongly in `file1.c`. References in `file2.c` resolve to this.
- The linker sees `weak_var` defined weakly in both `file1.c` and `file2.c`. It picks one (both are effectively zero-initialized).

## Related Concepts
- [[Symbol_C]] (Strong is a type of symbol)
- [[Weak_Symbol_C]] (The counterpart)
- [[Linker_C]], [[Symbol_Resolution_C]] (Where the strong/weak distinction matters)
- [[Function_C]], [[Global_Variable_C]] (Sources of strong symbols)
- [[Definition_C]] (Strong symbols correspond to concrete definitions)
- One Definition Rule (ODR) (Multiple strong symbols violate this)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Weak_Symbol_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, linker, symbol]
aliases: [C Weak Symbol]
related: [[Symbol_C]], [[Strong_Symbol_C]], [[Linker_C]], [[Symbol_Resolution_C]], [[Global_Variable_C]], [[BSS_Segment_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Weak Symbol (C Linker)

## Definition

In the context of the C [[Linker_C]], a **Weak Symbol** refers to a [[Symbol_C]] that has a "weak" definition. The most common example of a weak symbol is an **uninitialized global variable**. Some toolchains also provide mechanisms (like GCC's `__attribute__((weak))` or `#pragma weak`) to explicitly declare functions or initialized variables as weak.

The distinction between [[Strong_Symbol_C|strong]] and weak symbols is crucial for how the linker handles multiple definitions of the same global symbol during [[Symbol_Resolution_C]].

## Linker Rules (Strong vs. Weak)

The linker generally follows these rules when resolving global symbols:

1.  Multiple [[Strong_Symbol_C|strong symbols]] with the same name are not allowed (Linker error).
2.  Given one strong symbol and multiple weak symbols with the same name, choose the **strong symbol**. References resolve to the strong definition.
3.  Given multiple weak symbols with the same name, pick **one** of the weak symbols arbitrarily.

## Key Aspects & Use Cases

- **Uninitialized Globals:** The primary source of weak symbols in standard C. `int global_x;` defined at file scope creates a weak symbol `global_x`. These are placed in the [[BSS_Segment_C]].
- **Allowing Overrides:** Weak symbols allow a user or another library to provide a strong definition that overrides a default (weak) implementation. For example, a library might provide a function declared with `__attribute__((weak))`. If the user links their own strong definition of the same function, the linker will use the user's version; otherwise, it uses the library's weak version.
- **Optional Functionality:** Can be used to implement optional features. A core module might make weak references to functions defined in optional modules. If the optional module is linked in, the call resolves; if not, the weak reference might resolve to `NULL` or a default stub (if provided).
- **Potential for Confusion:** The rule allowing multiple weak symbols where the linker picks one arbitrarily can be confusing or lead to subtle bugs if the different weak definitions aren't truly identical (e.g., different sizes for uninitialized global arrays declared in different files).

## Examples

```c
// --- library.c ---
#include <stdio.h>

// Uninitialized global (Weak Symbol)
int optional_config_value;

// Explicit weak function (GCC attribute)
void __attribute__((weak)) optional_feature() {
    printf("Default weak implementation of optional_feature.\n");
    // If optional_config_value was set by user, could use it here.
    printf("  (Config value: %d)\n", optional_config_value);
}

void core_function() {
    printf("Core function running.\n");
    if (optional_feature) { // Check if it resolved (not NULL)
        optional_feature(); // Call the feature (might be default or user's)
    } else {
        // This case usually doesn't happen with GCC weak attribute,
        // it resolves to the weak definition if no strong one exists.
        printf("Optional feature not available.\n");
    }
}


// --- main.c ---
#include <stdio.h>

// Provide a strong definition for the config value
int optional_config_value = 123; // Strong symbol, overrides weak one

// Provide a strong definition for the optional feature
void optional_feature() {
    printf("USER's STRONG implementation of optional_feature!\n");
     printf("  (User sees config value: %d)\n", optional_config_value);
}

// Declare function from library
void core_function();

int main() {
    core_function();
    return 0;
}
```
**Linking `gcc library.c main.c -o main`:**
- `optional_config_value`: Linker sees weak definition in `library.c` and strong definition in `main.c`. It chooses the **strong** definition (value 123).
- `optional_feature`: Linker sees weak definition in `library.c` and strong definition in `main.c`. It chooses the **strong** definition (the user's version).
- `core_function` calls `optional_feature`, executing the user's strong version.

**Linking `gcc library.c -o main_lib_only` (if `main` was in `library.c`):**
- `optional_config_value`: Only weak definition exists. Resolves to the weak symbol (value 0).
- `optional_feature`: Only weak definition exists. Resolves to the weak symbol (default implementation).
- `core_function` calls `optional_feature`, executing the default weak version.

## Related Concepts
- [[Symbol_C]] (Weak is a type of symbol)
- [[Strong_Symbol_C]] (The counterpart)
- [[Linker_C]], [[Symbol_Resolution_C]] (Where the strong/weak distinction matters)
- [[Global_Variable_C]] (Uninitialized globals are weak)
- [[BSS_Segment_C]] (Where uninitialized globals are typically placed)
- Compiler Attributes/Pragmas (Mechanisms for explicitly creating weak symbols)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Static_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, keyword, scope, lifetime, linkage]
aliases: [static keyword C]
related: [[Static_Variable_C]], [[Static_Function_C]], [[Storage_Duration_C]], [[Linkage_C]], [[Scope_C]], [[Local_Variable_C]], [[Global_Variable_C]], [[Function_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# `static` Keyword (C)

## Definition

The `static` keyword in C is a **storage class specifier** that modifies the **storage duration** (lifetime) and/or **linkage** (visibility across files) of variables and functions, depending on the context where it is used.

## Meanings of `static`

1.  **Inside a Function Block (Local Variables):**
    -   `static` applied to a [[Local_Variable_C]] gives it **static storage duration** instead of the default automatic storage duration.
    -   **Effect:** The variable exists for the entire lifetime of the program, not just the function call. It retains its value between function calls. It is initialized only once (before program start or first function entry), and defaults to zero-initialization if no explicit initializer is given.
    -   **Scope:** Remains local to the function/block.
    -   See [[Static_Variable_C]] (Local Static Variables).
    ```c
    void counter() {
        static int count = 0; // Exists for program lifetime, initialized once
        count++;
        printf("%d ", count);
    } // main calling counter() 3 times prints "1 2 3 "
    ```

2.  **Outside Functions (Global Variables and Functions):**
    -   `static` applied to a global variable or a function definition gives it **internal linkage**.
    -   **Effect:** The variable or function becomes local to the specific source file (`.c` file) where it is defined. It cannot be accessed directly by name from other source files, even if declared with `extern` elsewhere. This helps prevent naming conflicts between different modules and hides implementation details.
    -   **Storage Duration:** Global variables declared `static` still have static storage duration (exist for program lifetime).
    -   See [[Static_Variable_C]] (Global Static Variables) and [[Static_Function_C]].
    ```c
    // --- file1.c ---
    static int file_secret = 10; // Internal linkage
    static void helper_function() { /* ... */ } // Internal linkage

    void public_function() { // External linkage (default)
        file_secret++;
        helper_function();
    }

    // --- file2.c ---
    // extern int file_secret; // LINKER ERROR: file_secret not visible
    // extern void helper_function(); // LINKER ERROR: helper_function not visible
    extern void public_function(); // OK: Has external linkage

    int main() { public_function(); return 0; }
    ```

3.  **Inside Function Parameters (Array Size - C99+):**
    -   In C99 and later, `static` can be used inside `[]` in function parameter declarations for arrays (e.g., `void func(int arr[static 10])`). This is a hint to the compiler that the pointer `arr` will point to the beginning of an array of *at least* 10 elements, potentially enabling optimizations. It does *not* change storage duration or linkage. This usage is less common.

## Summary Table

| Context                     | Effect of `static`                     | Scope   | Storage Duration | Linkage   | See Also                                          |
| :-------------------------- | :------------------------------------- | :------ | :--------------- | :-------- | :------------------------------------------------ |
| Local Variable (in func)    | Retains value between calls            | Local   | Static           | None      | [[Static_Variable_C]] (Local)                     |
| Global Variable (file scope)| Visible only within the current file | File    | Static           | Internal  | [[Static_Variable_C]] (Global)                    |
| Function (file scope)       | Visible only within the current file | File    | (N/A)            | Internal  | [[Static_Function_C]]                             |
| Array Param `[static N]`    | Hint: Array has at least N elements    | Local   | (N/A)            | (N/A)     | (Less common C99 feature)                         |

## Related Concepts
- [[Static_Variable_C]], [[Static_Function_C]] (Specific uses of the keyword)
- [[Storage_Duration_C]] (Static vs. Automatic)
- [[Linkage_C]] (Internal vs. External)
- [[Scope_C]] (Local vs. File)
- [[Global_Variable_C]], [[Local_Variable_C]], [[Function_C]] (Entities modified by `static`)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Static_Function_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, function, linkage, keyword, module]
aliases: [C Static Function]
related: [[Static_C]], [[Function_C]], [[Linkage_C]], [[Implementation_C]], [[Header_file_C]], [[Symbol_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Static Function (C)

## Definition

A **Static Function** in C is a [[Function_C]] declared with the `static` storage class specifier at file scope (outside any other function). The `static` keyword, when applied to a function, gives it **internal linkage**.

## Key Aspects / Characteristics

- **Internal Linkage:** A static function is only visible and callable within the specific source file (`.c` file) where it is defined. Its name is not exported by the [[Linker_C]] to other modules (object files).
- **Hiding Implementation Details:** Static functions are commonly used as "helper" functions within a module (a `.c` file) whose functionality is only needed by the public (non-static) functions within that same module. This helps to encapsulate the module's implementation and prevents polluting the global namespace.
- **Preventing Name Conflicts:** Since the function name is not visible outside the file, different source files can define static functions with the same name without causing linker errors.
- **Declaration:** If a static function is called before its definition within the same file, a forward declaration (prototype) marked `static` is needed: `static return_type function_name(params);`.
- **Not Related to Static Local Variables:** The `static` keyword here controls *linkage*, which is different from its use inside a function block where it controls *storage duration* ([[Static_Variable_C]]).

## Examples / Use Cases

**`module.c`:**
```c
#include <stdio.h>
#include "module.h" // Assume declares public_func()

// Static helper function (internal linkage)
static int internal_calculation(int x) {
    printf("  (Performing internal calculation on %d)\n", x);
    return x * x + 1;
}

// Another static helper
static void log_status(const char *status) {
     printf("  (Log: %s)\n", status);
}

// Public function (external linkage, declared in module.h)
int public_func(int value) {
    log_status("Entering public_func");
    int result = internal_calculation(value); // Call static helper
    log_status("Exiting public_func");
    return result;
}
```

**`main.c`:**
```c
#include <stdio.h>
#include "module.h" // Includes declaration for public_func()

// extern int internal_calculation(int); // LINKER ERROR if uncommented
// extern void log_status(const char*); // LINKER ERROR if uncommented

int main() {
    printf("Calling public function...\n");
    int res = public_func(5);
    printf("Result from public function: %d\n", res);

    // Cannot call static functions directly from here:
    // internal_calculation(10); // Compile or Linker Error
    // log_status("Test");       // Compile or Linker Error

    return 0;
}
```
**Linking `gcc module.c main.c -o main`:** This works because `main.c` only calls `public_func`, which has external linkage. The linker does not need to resolve `internal_calculation` or `log_status` outside of `module.c`.

## Related Concepts
- [[Static_C]] (The keyword used)
- [[Function_C]] (The entity being modified)
- [[Linkage_C]] (Specifically, internal linkage)
- [[Implementation_C]] (Static functions are part of the hidden implementation)
- [[Header_file_C]] (Static functions are usually *not* declared in header files)
- [[Symbol_C]] (Static functions result in local symbols)
- [[extern_Function_C]] (Functions with external linkage)

## Questions / Further Study
>[!question] What is a static Function? (WS6)
> A static function is a function defined with the `static` keyword at file scope. This gives the function **internal linkage**, meaning it can only be called by other functions within the same source file (`.c` file). It cannot be accessed directly by name from other files, helping to hide implementation details and prevent naming conflicts.

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/extern_Function_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, function, linkage, keyword, declaration]
aliases: [C Extern Function, External Linkage Function C]
related: [[extern_keyword_C]], [[Function_C]], [[Linkage_C]], [[Function_Declaration_C]], [[Static_Function_C]], [[Header_file_C]], [[Symbol_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Extern Function (C)

## Definition

In C, functions have **external linkage** by default. This means a function defined in one source file (`.c`) can be called from other source files, provided a [[Function_Declaration_C|declaration (prototype)]] is visible in the calling file. The `extern` keyword, when used with a function *declaration*, explicitly states that the function has external linkage and is defined elsewhere. However, since external linkage is the default for functions, the `extern` keyword is **optional and usually omitted** in function declarations.

## Key Aspects / Characteristics

- **External Linkage (Default):** Functions defined without the `static` keyword have external linkage. Their [[Symbol_C|symbol]] is visible to the [[Linker_C]] across different object files.
- **`extern` in Declarations:** Using `extern` in a function declaration (prototype) explicitly confirms the default external linkage.
    - `extern int func(void);` is equivalent to `int func(void);`
- **`extern` in Definitions:** Using `extern` in a function *definition* is technically allowed by the standard but is redundant and generally considered poor style.
    - `extern int func(void) { /* body */ }` is the same as `int func(void) { /* body */ }`
- **Purpose:** The primary role of `extern` (in the context of functions) is simply to declare a function defined in another file, making its signature known to the compiler in the current file. This is precisely the role of standard function prototypes, which is why `extern` is rarely seen in modern C function declarations.
- **Contrast with `static`:** Functions declared `static` have *internal* linkage and cannot be accessed from other files. See [[Static_Function_C]].

## Examples / Use Cases

**`utils.h`:**
```c
#ifndef UTILS_H
#define UTILS_H

// Standard function declaration (external linkage is default)
int utility_add(int a, int b);

// Explicit use of 'extern' (optional and equivalent)
extern void utility_print(int value);

#endif
```

**`utils.c`:**
```c
#include "utils.h" // Include own header
#include <stdio.h>

// Definition (external linkage by default)
int utility_add(int a, int b) {
    return a + b;
}

// Definition (external linkage by default)
void utility_print(int value) {
    printf("Utility print: %d\n", value);
}```

**`main.c`:**
```c
#include <stdio.h>
#include "utils.h" // Include declarations

int main() {
    int sum = utility_add(10, 5); // Call function defined elsewhere
    utility_print(sum);          // Call function defined elsewhere
    return 0;
}
```

## Related Concepts
- [[extern_keyword_C]] (The keyword itself)
- [[Function_C]] (The entity being declared/defined)
- [[Linkage_C]] (Specifically, external linkage)
- [[Function_Declaration_C]] (Prototypes are declarations, `extern` is optional)
- [[Static_Function_C]] (Contrast: internal linkage)
- [[Header_file_C]] (Where declarations are usually placed)
- [[Symbol_C]] (Extern functions produce global symbols)

## Questions / Further Study
>[!question] What is an extern Function? (WS6)
> An "extern function" usually refers to a function with **external linkage** (the default for functions not marked `static`). This means the function is defined in one `.c` file but can be called from other `.c` files. While you *can* use the `extern` keyword in the function's declaration (prototype) like `extern int my_func();`, it's optional and usually omitted because external linkage is the default. The key is that its definition is accessible across different compilation units via the linker.

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/API_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, design, module, interface, library]
aliases: [C API, Application Programming Interface C]
related: [[Interface_C]], [[Header_file_C]], [[Function_Declaration_C]], [[struct_C]], [[enum_C]], [[typedef_C]], [[Library_C]], [[Implementation_C]], [[Abstraction_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# API (Application Programming Interface) (C)

## Definition

In the context of C programming, an **API (Application Programming Interface)** is the set of public declarations (functions, types, constants, macros) that a library or software module exposes for use by other programs (clients or applications). It defines the stable "contract" or [[Interface_C]] through which clients interact with the library's functionality, hiding the underlying [[Implementation_C]].

## Key Aspects / Characteristics

- **Public Interface:** Defines *how* external code should interact with the library/module.
- **Specification:** Consists primarily of declarations found in public [[Header_file_C|header files (`.h`)]].
- **Components:** Typically includes:
    - Public [[Function_Declaration_C|function prototypes]].
    - Public data type definitions ([[struct_C]], [[union_C]], [[enum_C]], [[typedef_C]]). Often uses [[Opaque_Pointer_C]] to hide internal structure details.
    - Public macro definitions (`#define`) for constants or utility macros.
    - Documentation explaining how to use the functions and types.
- **Abstraction:** Hides the complexity of the internal implementation. Clients use the API without needing to know *how* it works internally.
- **Stability:** A well-designed API aims for stability. Changes to the implementation should ideally not require changes to client code as long as the API contract remains the same. Breaking API changes (e.g., changing function signatures, removing functions) require clients to update their code.
- **Libraries:** APIs are fundamental to using [[Library_C|libraries]] (both static and shared). The library provides header files (the API) and compiled object code (the implementation).

## Examples / Use Cases

- **C Standard Library:** The functions declared in `<stdio.h>`, `<stdlib.h>`, `<string.h>`, etc., form the API of the standard C library. For example, `printf`, `malloc`, `strcpy` are part of this API.
- **Operating System APIs:** POSIX API (functions like `open`, `read`, `write`, `fork`, `pthread_create`) or Windows API (Win32 functions) provide interfaces to OS services.
- **Third-Party Libraries:** Libraries for graphics (e.g., SDL, OpenGL), networking (e.g., libcurl), data handling (e.g., zlib) all expose APIs through their header files.
- **Internal Modules:** Within a large project, different components can expose APIs to each other via internal header files.

*(See example header file in [[Header_file_C]] or [[Interface_C]])*

## Related Concepts
- [[Interface_C]] (API is largely synonymous with the public interface)
- [[Header_file_C]] (Where the API is typically declared)
- [[Implementation_C]] (The code *behind* the API)
- [[Library_C]] (APIs provide access to libraries - *to be created*)
- [[Abstraction_C]], [[Encapsulation_C]] (Design principles embodied by APIs)
- [[Function_Declaration_C]], [[struct_C]], etc. (Components of an API)
- API Documentation (Crucial for usability)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/ar_command.md`**
*(Use `T_Command.md` template)*

```markdown
---
tags: [c, tool, build_process, linker, library, static_library, archive]
aliases: [ar archiver]
related: [[Build_Process_C]], [[Static_Library_C]], [[Object_File_C]], [[Linker_C]], [[nm_command]], [[ranlib_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# ` ar ` (Archiver)

## Purpose

The `ar` (archiver) command is a standard Unix utility used to create, modify, and extract files from **archives**. In the context of C programming, its primary use is to create and manage [[Static_Library_C|static libraries]] (`.a` files). A static library is essentially an archive file containing multiple [[Object_File_C|object files (`.o`)]].

## Syntax

```bash
ar [options] archive-file [member-file...]
```

## Common Options (for Static Libraries)

| Option | Description                                                                                                |
| :----- | :--------------------------------------------------------------------------------------------------------- |
| `r`    | **Replace/Insert:** Insert the specified `member-file`(s) into the archive. If a member with the same name already exists, it is replaced. New members are added at the end. |
| `c`    | **Create:** Create the archive if it doesn't exist. Often used with `r` (i.e., `rc` or `cr`). Suppresses the warning normally issued when creating a new archive. |
| `s`    | **Symbol Index:** Create or update an index of symbols defined by the object file members within the archive. This index helps the [[Linker_C]] quickly find which object files within the library contain needed symbols. Equivalent to running `ranlib` on the archive. **Crucial for static libraries.** |
| `t`    | **Table of Contents:** Display a table listing the contents (member file names) of the archive.             |
| `x`    | **Extract:** Extract the specified `member-file`(s) from the archive. If no members are specified, extracts all members. |
| `d`    | **Delete:** Delete the specified `member-file`(s) from the archive.                                        |
| `v`    | **Verbose:** Provide verbose output about the actions being performed.                                     |

## Examples

**Example 1: Create a static library**
```bash
# Assume we have compiled object files: utils.o, math.o, string_helper.o
gcc -c utils.c -o utils.o
gcc -c math.c -o math.o
gcc -c string_helper.c -o string_helper.o

# Create a static library named 'libmylib.a' containing these object files
# 'rcs' = replace/insert, create if needed, create symbol index
ar rcs libmylib.a utils.o math.o string_helper.o

# Verify contents
ar t libmylib.a
# Output might show:
# utils.o
# math.o
# string_helper.o
```

**Example 2: Add/Update an object file in the library**
```bash
# Recompile utils.c
gcc -c utils.c -o utils.o

# Update utils.o in the archive (and update index)
ar rs libmylib.a utils.o
```

**Example 3: Link against the static library**
```bash
# Compile main program
gcc -c main.c -o main.o

# Link main.o with libmylib.a
# -L. tells linker to look in current directory for libraries
# -lmylib tells linker to link with 'libmylib.a'
gcc main.o -L. -lmylib -o my_program
# Or directly: gcc main.o libmylib.a -o my_program
```

## Related Commands/Concepts
- [[Static_Library_C]] (The type of file `ar` creates/manages)
- [[Object_File_C]] (The members added to the archive)
- [[Build_Process_C]] (Creating libraries is part of the build)
- [[Linker_C]] (Uses the static libraries created by `ar`)
- [[ranlib_C]] (Older command, equivalent to `ar s`, sometimes needed on older systems - *to be created*)
- [[nm_command]] (Lists symbols in object files or libraries)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/nm_command.md`**
*(Use `T_Command.md` template)*

```markdown
---
tags: [c, tool, build_process, linker, symbol, debugging, object_file, library, executable]
aliases: [nm list symbols]
related: [[Build_Process_C]], [[Symbol_C]], [[Symbol_Table_C]], [[Object_File_C]], [[Static_Library_C]], [[Shared_Library_C]], [[Executable_File_C]], [[Linker_C]], [[ar_command]], [[objdump_command]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# ` nm ` (List Symbols)

## Purpose

The `nm` command is a standard Unix utility used to list the **symbols** defined in or referenced by [[Object_File_C|object files]], [[Static_Library_C|static libraries (`.a`)]], [[Shared_Library_C|shared libraries (`.so`)]], and [[Executable_File_C|executable files]]. It reads the [[Symbol_Table_C]] within these files. This is useful for debugging linking problems, inspecting library contents, and understanding which functions and variables are defined or needed.

## Syntax

```bash
nm [options] [file...]
```

## Common Options

| Option        | Description                                                                 |
| :------------ | :-------------------------------------------------------------------------- |
| `-A`, `-o`    | Precede each symbol line with the input file name.                          |
| `-g`          | Display only global (external) symbols.                                     |
| `-u`          | Display only undefined symbols (those referenced but not defined in the file). |
| `-C`, `--demangle`| Decode (demangle) low-level symbol names into user-level names. Especially useful for C++ symbols. |
| `-n`, `-v`    | Sort symbols numerically by address.                                        |
| `-p`          | Do not sort; display symbols in the order encountered in the symbol table.  |
| `-r`          | Reverse the order of the sort.                                              |
| `-S`          | Print size along with value for defined symbols.                            |
| `-t <format>` | Specify radix for numeric values (d=decimal, o=octal, x=hexadecimal). Default is hex. |

## Output Format

The default output format typically includes three columns:

1.  **Value (Address):** The address or value associated with the symbol (hexadecimal by default).
2.  **Type:** A character indicating the symbol type. Common types include:
    -   `T` or `t`: Symbol is in the text (code) section. `T` = global, `t` = local/static.
    -   `D` or `d`: Symbol is in the initialized data section. `D` = global, `d` = local/static.
    -   `B` or `b`: Symbol is in the BSS (uninitialized data) section. `B` = global, `b` = local/static.
    -   `U`: Symbol is undefined (referenced but not defined in this file).
    -   `W` or `w`: Weak symbol. `W` = global, `w` = local.
    -   `A`: Absolute symbol (value won't change during linking).
    -   `C`: Common symbol (uninitialized data, like weak BSS symbols).
    -   `?`: Symbol type unknown or specific to object file format.
3.  **Name:** The name of the symbol.

## Examples

**Assume `math_utils.o` defines `add` and `global_count`, and `main.o` defines `main` and references `add` and `global_count`.**

**Example 1: List all symbols in an object file**
```bash
nm math_utils.o
# Output might look like:
# 0000000000000004 C global_count  # Common (weak BSS) symbol
# 0000000000000000 T add           # Text (code) symbol, global
```

**Example 2: List undefined symbols in an object file**
```bash
nm -u main.o
# Output might look like:
#                  U add           # Undefined, needs linking
#                  U global_count  # Undefined, needs linking
#                  U printf        # Undefined (from standard library)
```

**Example 3: List global symbols in a static library**
```bash
# Assume libmymath.a contains math_utils.o
nm -g libmymath.a
# Output might show symbols from multiple object files within the archive:
#
# math_utils.o:
# 0000000000000004 C global_count
# 0000000000000000 T add
# ... other object files ...
```

**Example 4: List symbols in an executable**
```bash
nm my_program
# Shows symbols from all linked object files and potentially dynamic symbols
# (Addresses will be final virtual addresses)
```

## Related Commands/Concepts
- [[Symbol_C]], [[Symbol_Table_C]] (The data displayed by `nm`)
- [[Object_File_C]], [[Static_Library_C]], [[Shared_Library_C]], [[Executable_File_C]] (Files inspected by `nm`)
- [[Linker_C]] (Resolves the undefined symbols shown by `nm -u`)
- [[Strong_Symbol_C]], [[Weak_Symbol_C]] (Reflected in the symbol type character)
- [[ar_command]] (Creates static libraries inspected by `nm`)
- [[objdump_command]] (Provides more detailed information, including disassembly)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/objdump_command.md`**
*(Use `T_Command.md` template)*

```markdown
---
tags: [c, tool, build_process, debugging, disassembly, object_file, library, executable]
aliases: [objdump]
related: [[Build_Process_C]], [[Object_File_C]], [[Static_Library_C]], [[Shared_Library_C]], [[Executable_File_C]], [[Assembly_Language_C]], [[Machine_Code_C]], [[Symbol_C]], [[Symbol_Table_C]], [[nm_command]], [[readelf_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# ` objdump `

## Purpose

The `objdump` command is a versatile utility (part of GNU Binutils) used to display information about [[Object_File_C|object files]], [[Static_Library_C|static libraries]], [[Shared_Library_C|shared libraries]], and [[Executable_File_C|executable files]]. Its most common use is to **disassemble** the executable sections (code) to show the [[Assembly_Language_C|assembly language]] instructions corresponding to the compiled [[Machine_Code_C]]. It can also display file headers, section information, symbol tables, and relocation entries.

## Syntax

```bash
objdump [options] file...
```

## Common Options

| Option        | Description                                                                 |
| :------------ | :-------------------------------------------------------------------------- |
| `-d`, `--disassemble` | Disassemble executable sections into assembly code.                     |
| `-D`, `--disassemble-all`| Disassemble all sections, not just executable ones.                 |
| `-S`, `--source`  | Intermix source code with disassembly (requires compilation with debug info, e.g., `gcc -g`). |
| `-l`          | Include filename and line numbers in disassembly (requires debug info).     |
| `-t`, `--syms`    | Display the file's symbol table entries (similar to `nm`).                |
| `-T`, `--dynamic-syms`| Display the dynamic symbol table entries (for shared libraries/dynamic executables). |
| `-h`, `--section-headers`, `--headers`| Display summary information from section headers.       |
| `-x`, `--all-headers`| Display all available header information, including symbols and relocations. |
| `-r`, `--reloc`   | Display the relocation entries in the file.                             |
| `-j <section>`, `--section=<section>`| Display information only for the specified section name. |
| `-M <dialect>`, `--disassembler-options=<dialect>`| Specify assembly dialect (e.g., `intel`, `att`). Default is usually AT&T syntax on Linux. |

## Examples

**Assume `program.o` is an object file and `program` is the linked executable.**

**Example 1: Disassemble executable sections**
```bash
objdump -d program
# Output shows assembly instructions for functions like main, etc.
```

**Example 2: Disassemble with source code interleaved (compile with -g)**
```bash
gcc -g main.c -o program # Compile with debug info
objdump -S program
# Output shows C source lines followed by corresponding assembly
```

**Example 3: Show symbol table**
```bash
objdump -t program.o
# Similar output to nm, listing symbols, values, types, sections
```

**Example 4: Show section headers**
```bash
objdump -h program
# Lists sections like .text, .data, .bss, .rodata, etc., with their sizes and addresses
```

**Example 5: Disassemble using Intel syntax**
```bash
objdump -d -M intel program
# Shows disassembly using Intel syntax (e.g., 'mov eax, ebx' instead of 'mov %ebx, %eax')
```

## Related Commands/Concepts
- [[Object_File_C]], [[Executable_File_C]], Libraries (Files analyzed by `objdump`)
- [[Assembly_Language_C]], [[Machine_Code_C]] (Displayed by disassembly options)
- [[Symbol_C]], [[Symbol_Table_C]] (Can be displayed with `-t`)
- [[Build_Process_C]] (Useful for inspecting build artifacts)
- [[Debugging_Techniques_C]] (Understanding disassembly can aid debugging)
- [[nm_command]] (Alternative/simpler tool specifically for listing symbols)
- [[readelf_C]] (Another powerful tool on Linux for displaying ELF file information - *to be created*)
- Debug Information (`-g` flag during compilation)

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Build_Process_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, tool, core]
aliases: [C Compilation Process, C Build Steps]
related: [[Source_File_C]], [[Header_file_C]], [[Preprocessor_C]], [[Compiler_C]], [[Assembler_C]], [[Object_File_C]], [[Linker_C]], [[Static_Library_C]], [[Shared_Library_C]], [[Executable_File_C]], [[Makefile_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# Build Process (C)

## Definition

The **C Build Process** refers to the sequence of steps required to transform human-readable C source code (`.c` files) and header files (`.h` files) into an executable program (`.exe` on Windows, typically no extension on Linux/macOS) that the computer can run. This process typically involves four main stages: Preprocessing, Compilation, Assembly, and Linking.

## Stages of the Build Process

1.  **[[Preprocessor_C|Preprocessing]]:**
    -   **Input:** Source code file (`.c`).
    -   **Action:** The preprocessor handles directives starting with `#`. It removes comments, expands macros (`#define`), includes header files (`#include`), and handles conditional compilation (`#if`, `#ifdef`, etc.).
    -   **Output:** A single, expanded "translation unit" or "compilation unit" - essentially C code with all directives processed. (Often an intermediate file like `.i` or just passed in memory).

2.  **[[Compiler_C|Compilation]]:**
    -   **Input:** Preprocessed source code (translation unit).
    -   **Action:** The compiler parses the C code, performs syntax and semantic analysis, applies optimizations, and translates the code into architecture-specific **assembly language**.
    -   **Output:** Assembly code file (often `.s` or `.asm`).

3.  **[[Assembler_C|Assembly]]:**
    -   **Input:** Assembly code file (`.s`).
    -   **Action:** The assembler translates the assembly language instructions into **relocatable machine code** (binary instructions and data).
    -   **Output:** An [[Object_File_C|object file]] (typically `.o` on Unix-like systems, `.obj` on Windows). This file contains the machine code, data, and a [[Symbol_Table_C|symbol table]] listing defined/referenced symbols.

4.  **[[Linker_C|Linking]]:**
    -   **Input:** One or more object files (`.o`) and potentially [[Static_Library_C|static libraries (`.a`)]] or references to [[Shared_Library_C|shared libraries (`.so`, `.dll`)]].
    -   **Action:** The linker resolves external symbol references (matching function calls/variable uses in one file to definitions in another), combines code and data sections from all input files, performs [[Relocation_C|relocation]] to assign final memory addresses, and incorporates necessary library code.
    -   **Output:** A final [[Executable_File_C|executable file]] (or sometimes a shared library).

## Toolchain

These stages are typically performed by a set of tools called a **toolchain**. Common C toolchains include:
-   **GNU Toolchain:** [[GCC]] (driver program invoking preprocessor, compiler, assembler, linker), Binutils ([[ld]] linker, [[as]] assembler, [[ar_command|ar]], [[nm_command|nm]], [[objdump_command|objdump]], etc.), [[glibc]] (C library).
-   **LLVM/Clang:** [[Clang_C]] (front-end invoking preprocessor, compiler), LLVM (backend for optimization, code generation), lld (linker), libc++ (C++ library).
-   **Microsoft Visual Studio:** Includes MSVC compiler, linker, libraries, etc.

## Example (Using GCC)

```bash
# 1. Preprocessing only (-E)
gcc -E main.c -o main.i

# 2. Compilation only (-S, produces assembly)
gcc -S main.i -o main.s # Or directly: gcc -S main.c -o main.s

# 3. Assembly only (-c, produces object file)
gcc -c main.s -o main.o # Or directly: gcc -c main.c -o main.o

# 4. Linking only (using previously created object file)
# Assume utils.o also exists
gcc main.o utils.o -o my_program

# --- Common Combined Steps ---

# Compile and Assemble (-c)
gcc -c main.c -o main.o
gcc -c utils.c -o utils.o

# Link object files
gcc main.o utils.o -o my_program

# --- All steps in one command ---
gcc main.c utils.c -o my_program
```

## Related Concepts
- All the stage components: [[Preprocessor_C]], [[Compiler_C]], [[Assembler_C]], [[Linker_C]].
- Input/Output files: [[Source_File_C]], [[Header_file_C]], [[Object_File_C]], [[Static_Library_C]], [[Shared_Library_C]], [[Executable_File_C]].
- [[Makefile_C]] (Tool for automating the build process - *to be created*).

## Questions / Further Study
>[!question] Describe the software's build process from C sources to a running program. (WS6)
> 1.  **Preprocessing:** Source `.c` files are processed to handle `#include`, `#define`, and conditional compilation, producing expanded C code.
> 2.  **Compilation:** The expanded C code is translated into architecture-specific assembly language.
> 3.  **Assembly:** The assembly code is translated into relocatable machine code, stored in object files (`.o`).
> 4.  **Linking:** Object files and necessary libraries are combined. The linker resolves symbol references between files and assigns final addresses, producing a single executable file.
> 5.  **(Execution):** The [[Operating_System]] [[Loader_C|loader]] takes the executable, loads it into memory, performs dynamic linking (if needed), sets up the process environment, and starts execution at the program's entry point (usually leading to `main`).

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/#include_directive_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, build_process, preprocessor, directive, header_file]
aliases: [#include C]
related: [[Preprocessor_C]], [[Header_file_C]], [[Build_Process_C]], [[Compiler_C]], [[Linker_C]]
worksheet: [C_WS6]
date_created: 2025-04-21
---
# `#include` Directive (C)

## Definition

The `#include` directive is a [[Preprocessor_C|preprocessor]] directive in C used to insert the contents of another file (typically a [[Header_file_C|header file]]) into the source code file at the point where the directive appears. This is the standard mechanism for making declarations (of functions, types, variables, macros) defined in one file available for use in another file before compilation.

## Syntax

There are two common forms:

1.  **`#include <filename.h>`** (Angle Brackets):
    -   Used primarily for including standard library headers (e.g., `<stdio.h>`, `<stdlib.h>`) and potentially other system-wide or library headers.
    -   The preprocessor searches for the file in a standard list of system directories, often specified by compiler settings or environment variables (e.g., `-I` flag in GCC/Clang). It typically does *not* search the current directory first.

2.  **`#include "filename.h"`** (Double Quotes):
    -   Used primarily for including header files created by the programmer for their own project.
    -   The preprocessor typically searches for the file first in the same directory as the current source file, and *then* searches the standard system directories (though the exact search path order can be implementation-defined or configured).

## Action

-   When the preprocessor encounters an `#include` directive, it replaces that line with the entire textual content of the specified file.
-   This inclusion happens recursively; if the included file itself contains `#include` directives, those files are also included.
-   This process occurs *before* the [[Compiler_C]] starts parsing the C code.

## Purpose

-   **Share Declarations:** Allows code in one `.c` file to use functions, types, macros, etc., declared in header files.
-   **Modularity:** Supports breaking a program into multiple source files and modules by providing access to shared interfaces defined in headers.
-   **Use Libraries:** Provides access to the declarations needed to use standard library functions or third-party library functions.

## Examples

```c
// --- my_math.h ---
#ifndef MY_MATH_H
#define MY_MATH_H
int add(int a, int b); // Function declaration
#endif

// --- main.c ---
#include <stdio.h>    // Include standard library header (using <>)
#include "my_math.h"  // Include project header (using "")

int main() {
    int result = add(5, 3); // Call function declared in my_math.h
    printf("Result: %d\n", result); // Use function declared in <stdio.h>
    return 0;
}

// --- my_math.c ---
#include "my_math.h" // Include own header (good practice)

int add(int a, int b) { // Function definition
    return a + b;
}```
When compiling `main.c`, the preprocessor effectively replaces `#include <stdio.h>` with the content of the system's `stdio.h` file and `#include "my_math.h"` with the content of the local `my_math.h` file before the compiler sees the code.

## Related Concepts
- [[Preprocessor_C]] (Executes the directive)
- [[Header_file_C]] (The files being included)
- [[Build_Process_C]] (Inclusion happens during preprocessing)
- [[Header_Guard_C]] (Needed to prevent issues from multiple inclusions)
- [[Compiler_C]] (Processes the code *after* inclusion)
- Search Paths (Where the preprocessor looks for included files)

## Questions / Further Study
>[!question] What is the difference between `#include <funcs.h>` and `#include "funcs.h"`? (WS6)
> - **`#include <funcs.h>`** (Angle Brackets): Tells the preprocessor to search for `funcs.h` primarily in the standard system include directories (and directories specified via compiler options like `-I`). It's used for standard library headers and headers from installed third-party libraries.
> - **`#include "funcs.h"`** (Double Quotes): Tells the preprocessor to search *first* in the directory containing the current source file, and *then* in the standard system include directories. It's used for header files that are part of the current project.

>[!question] What are the different ways to compile source files which include headers located in different directories? Which would we want to use and why? (WS6)
> Assume `main.c` includes `../include/myheader.h`.
> 1.  **Relative Paths in `#include`:**
>     -   Code: `#include "../include/myheader.h"`
>     -   Compile: `gcc src/main.c ...` (assuming main.c is in a `src` dir)
>     -   Pros: Simple for small projects.
>     -   Cons: Brittle; breaks if files are moved. Makes include paths dependent on the location of the `.c` file, not the project root or build command location. Generally discouraged for larger projects.
> 2.  **Compiler Include Path Flag (`-I`):**
>     -   Code: `#include "myheader.h"` (or maybe `myproject/myheader.h` if using subdirs in include path)
>     -   Compile: `gcc src/main.c -I../include ...`
>     -   Pros: **Preferred method.** Keeps `#include` directives clean and relative to the specified include roots. Decouples source code from the exact directory structure. Build system (like Make) manages the `-I` paths.
>     -   Cons: Requires configuring the build command or build system.
> 3.  **Symbolic Links:** Create symlinks within the source directories pointing to header locations (less common, platform-dependent, adds complexity).
> 4.  **Copying Headers:** Copy headers to a central location during the build (adds complexity, potential for staleness).
>
> **Conclusion:** Using the compiler's include path flag (`-I` for GCC/Clang, `/I` for MSVC) managed by a build system ([[Makefile_C]]) is the most robust, flexible, and conventional approach for handling headers in different directories.

---
**Source:** Worksheet C_WS6
```

**File: `30_C_Programming/Storage_Duration_C.md`**
*(Use `T_Concept.md` template)*

```markdown
---
tags: [c, concept, memory, lifetime, variable, function]
aliases: [C Storage Duration, Lifetime C]
related: [[Memory_Segments_C]], [[Automatic_Variable_C]], [[Static_Variable_C]], [[Dynamic_Allocation_C]], [[Scope_C]], [[Linkage_C]], [[static_keyword_C]], [[auto_keyword_C]], [[extern_keyword_C]], [[register_keyword_C]]
worksheet: [C_WS6] # Related to lifetime question
date_created: 2025-04-21
---
# Storage Duration (C)

## Definition

**Storage Duration** in C determines the **lifetime** of the memory associated with an object (variable). It specifies when memory is allocated for the object and when that memory is (or becomes eligible to be) deallocated or reused. C defines four main storage durations.

## Storage Durations

1.  **Automatic Storage Duration:**
    -   **Applies to:** [[Automatic_Variable_C|Non-static local variables]] (including function parameters). Variables declared inside a block or function without `static`, `extern`, or `_Thread_local`.
    -   **Lifetime:** Begins when the defining block or function is entered and ends when that block or function is exited.
    -   **Storage:** Typically allocated on the [[Stack_Memory_C|call stack]]. Memory is automatically managed.
    -   **Initialization:** Not initialized by default (contains garbage) unless explicitly initialized. Re-initialized (if initializer present) each time the block/function is entered.
    -   **Keywords:** `auto` (default, rarely used). `register` is a hint to the compiler to use a CPU register (also implies `auto`, cannot take address `&`).

2.  **Static Storage Duration:**
    -   **Applies to:** [[Global_Variable_C|Global variables]] (defined outside functions), [[Static_Variable_C|static global variables]], and [[Static_Variable_C|static local variables]].
    -   **Lifetime:** Exists for the **entire duration** of the program's execution. Memory is allocated when the program starts (or potentially at load time) and deallocated only when the program terminates.
    -   **Storage:** Allocated in the [[Data_Segment_C]] (if initialized non-zero) or [[BSS_Segment_C]] (if uninitialized or zero-initialized).
    -   **Initialization:** Initialized **only once**, before program execution begins (or before first entry for static locals). Implicitly zero-initialized if no explicit initializer is provided. Retains value between function calls (for static locals).
    -   **Keywords:** `static`, `extern` (for global variables, `extern` declares without defining but implies static duration).

3.  **Allocated Storage Duration (Dynamic):**
    -   **Applies to:** Memory allocated dynamically at runtime using [[malloc]], [[calloc_C]], or [[realloc_C]].
    -   **Lifetime:** Begins when the allocation function successfully returns a pointer and ends **only** when the memory is explicitly deallocated by passing that pointer to [[free]]. The lifetime is entirely controlled by the programmer, independent of block or function scopes.
    -   **Storage:** Allocated from the [[Heap_Memory_C|heap]].
    -   **Initialization:** `malloc` does not initialize. `calloc` initializes to zero bits.
    -   **Keywords:** None directly associated, managed via library functions.

4.  **Thread Storage Duration (C11+):**
    -   **Applies to:** Variables declared with `_Thread_local`.
    -   **Lifetime:** Exists for the entire lifetime of the specific thread in which it is created. Each thread gets its own separate instance of the variable.
    -   **Storage:** Implementation-defined (thread-local storage area).
    -   **Initialization:** Similar rules to static duration, but occurs when the thread starts.
    -   **Keywords:** `_Thread_local`.

## Relationship with Scope and Linkage

-   **[[Scope_C|Scope]]** determines *where* in the source code an identifier is visible.
-   **Storage Duration** determines *when* the object exists in memory (its lifetime).
-   **[[Linkage_C|Linkage]]** determines *whether* the same identifier declared in different scopes or files refers to the same object (Internal, External, None).

These are distinct concepts, though often related (e.g., automatic variables always have block scope and no linkage; non-static global variables have static duration, file scope, and external linkage).

## Related Concepts
- [[Automatic_Variable_C]], [[Static_Variable_C]], [[Dynamic_Allocation_C]], Thread-Local Storage
- [[Memory_Segments_C]] (Stack, Data, BSS, Heap)
- [[Lifetime_C]] (Synonym for storage duration - *to be created*)
- [[Scope_C]], [[Linkage_C]] (Related but distinct concepts)
- Keywords: `static`, `auto`, `extern`, `register`, `_Thread_local`

## Questions / Further Study
>[!question] What is the lifetime of a variable? (WS6)
> The lifetime of a variable is determined by its **[[Storage_Duration_C|storage duration]]**.
> - **Automatic:** Lifetime is limited to the execution of the block/function where it's defined (e.g., local variables on the stack).
> - **Static:** Lifetime spans the entire execution of the program (e.g., global variables, static local variables).
> - **Allocated (Dynamic):** Lifetime starts with `malloc`/`calloc`/`realloc` and ends only when `free` is called.
> - **Thread:** Lifetime spans the execution of the specific thread.

---
**Source:** Worksheet C_WS6
```

---
This concludes the processing for the C programming worksheets (WS1, WS3, WS4, WS5, WS6) based on the provided keywords, functions, commands, and questions. The relevant concepts and answers should now be integrated into the created Markdown files. Remember to review and potentially add more detail or cross-links as you use and expand this knowledge base.